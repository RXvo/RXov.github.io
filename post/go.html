<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go's Learning | Live Your Life</title><meta name="keywords" content="Golang"><meta name="author" content="Rxov"><meta name="copyright" content="Rxov"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Golang的学习之路">
<meta property="og:type" content="article">
<meta property="og:title" content="Go&#39;s Learning">
<meta property="og:url" content="https://rxvo.github.io/post/go.html">
<meta property="og:site_name" content="Live Your Life">
<meta property="og:description" content="Golang的学习之路">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&refer=http%3A%2F%2Fi2.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1638856406&t=f2a64ef1b887e37b9d00add7521ea926">
<meta property="article:published_time" content="2021-11-07T05:40:37.000Z">
<meta property="article:modified_time" content="2021-11-19T13:54:51.033Z">
<meta property="article:author" content="Rxov">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&refer=http%3A%2F%2Fi2.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1638856406&t=f2a64ef1b887e37b9d00add7521ea926"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rxvo.github.io/post/go"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8586c99fd6df25e156703e50b90263bb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go\'s Learning',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-19 21:54:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/footers.css"><link rel="stylesheet" href="/css/Lete.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://z3.ax1x.com/2021/05/14/gymhKH.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-video"></i><span> 微语</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638856406&amp;t=f2a64ef1b887e37b9d00add7521ea926')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Live Your Life</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-video"></i><span> 微语</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go's Learning</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-07T05:40:37.000Z" title="发表于 2021-11-07 13:40:37">2021-11-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-19T13:54:51.033Z" title="更新于 2021-11-19 21:54:51">2021-11-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Go%E8%AF%AD%E8%A8%80/">Go语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Go's Learning"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/go.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/go.html" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="安装配置相关"><a href="#安装配置相关" class="headerlink" title="安装配置相关"></a>安装配置相关</h1><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><p> 配置Go mod镜像（使用VSCode）解决导包FAILED的问题</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.4.md">主要参考1</a></li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45914985/article/details/109555913?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=vs%E9%85%8D%E7%BD%AEgo&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-109555913.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187">主要参考2</a></li>
</ul>
<h1 id="Go语言基础"><a href="#Go语言基础" class="headerlink" title="Go语言基础"></a>Go语言基础</h1><h2 id="二十五个关键字"><a href="#二十五个关键字" class="headerlink" title="二十五个关键字"></a>二十五个关键字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break    default      func    interface    select</span><br><span class="line">case     defer        go      map          struct</span><br><span class="line">chan     else         goto    package      switch</span><br><span class="line">const    fallthrough  if      range        type</span><br><span class="line">continue for          import  return       var</span><br></pre></td></tr></table></figure>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p> Go使用package（和Python的模块类似）来组织代码。main.main()函数(这个函数位于主包）是每一个独立的可运行程序的入口点。Go使用UTF-8字符串和标识符(因为UTF-8的发明者也就是Go的发明者之一)，所以它天生支持多语言。</p>
<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p> 使用var关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面：<br> 单变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量</span><br><span class="line">var variableName type</span><br></pre></td></tr></table></figure><br> 多变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//定义三个类型都是“type”的变量</span><br><span class="line">var vname1, vname2, vname3 type</span><br></pre></td></tr></table></figure><br> 定义变量并初始化值:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//初始化“variableName”的变量为“value”值，类型是“type”</span><br><span class="line">var variableName type = value</span><br></pre></td></tr></table></figure><br> 同时初始化多个变量:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">	定义三个变量，它们分别初始化为相应的值</span><br><span class="line">	vname1为v1，vname2为v2，vname3为v3</span><br><span class="line">	然后Go会根据其相应值的类型来帮你初始化它们</span><br><span class="line">*/</span><br><span class="line">var vname1, vname2, vname3 = v1, v2, v3</span><br></pre></td></tr></table></figure><br> 简化方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">	定义三个变量，它们分别初始化为相应的值</span><br><span class="line">	vname1为v1，vname2为v2，vname3为v3</span><br><span class="line">	编译器会根据初始化的值自动推导出相应的类型</span><br><span class="line">*/</span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure><br> :=这个符号直接取代了var和type,这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用var方式来定义全局变量。</p>
<p> Go对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了i但未使用;<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var i int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p> 在Go程序中，常量可定义为数值、布尔值或字符串等类型。<br> 用法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const constantName = value</span><br><span class="line">//如果需要，也可以明确指定常量的类型：</span><br><span class="line">const Pi float32 = 3.1415926</span><br></pre></td></tr></table></figure><br> Go常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)， 若指定給float32自动缩短为32bit，指定给float64自动缩短为64bit，详情参考<a target="_blank" rel="noopener" href="http://golang.org/ref/spec#Constants">链接</a></p>
<h2 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p> 在Go中，布尔值的类型为bool，值是true或false，默认为false。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//示例代码</span><br><span class="line">var isActive bool  // 全局变量声明</span><br><span class="line">var enabled, disabled = true, false  // 忽略类型的声明</span><br><span class="line">func test() &#123;</span><br><span class="line">	var available bool  // 一般声明</span><br><span class="line">	valid := false      // 简短声明</span><br><span class="line">	available = true    // 赋值操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p> Go里面也有直接定义好位数的类型：rune, int8, int16, int32, int64和byte, uint8, uint16, uint32, uint64。<br> 浮点数的类型有float32和float64两种（没有float类型），默认是float64。此外还支持复数。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p> Go中的字符串都是采用UTF-8字符集编码。字符串是用一对双引号（””）或反引号（<code> </code>）括起来定义，它的类型是string。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//示例代码</span><br><span class="line">var frenchHello string  // 声明变量为字符串的一般方法</span><br><span class="line">var emptyString string = &quot;&quot;  // 声明了一个字符串变量，初始化为空字符串</span><br><span class="line">func test() &#123;</span><br><span class="line">	no, yes, maybe := &quot;no&quot;, &quot;yes&quot;, &quot;maybe&quot;  // 简短声明，同时声明多个变量</span><br><span class="line">	japaneseHello := &quot;Konichiwa&quot;  // 同上</span><br><span class="line">	frenchHello = &quot;Bonjour&quot;  // 常规赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s string = &quot;hello&quot;</span><br><span class="line">s[0] = &#x27;c&#x27;</span><br></pre></td></tr></table></figure><br> 想要修改可以使用下面代码实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;hello&quot;</span><br><span class="line">c := []byte(s)  // 将字符串 s 转换为 []byte 类型</span><br><span class="line">c[0] = &#x27;c&#x27;</span><br><span class="line">s2 := string(c)  // 再转换回 string 类型</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, s2)</span><br></pre></td></tr></table></figure><br> Go中可以使用+操作符来连接两个字符串：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;hello,&quot;</span><br><span class="line">m := &quot; world&quot;</span><br><span class="line">a := s + m</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, a)</span><br></pre></td></tr></table></figure><br> 修改字符串也可写为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;hello&quot;</span><br><span class="line">s = &quot;c&quot; + s[1:] // 字符串虽不能更改，但可进行切片操作</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, s)</span><br></pre></td></tr></table></figure></p>
<h3 id="Go数据底层的存储"><a href="#Go数据底层的存储" class="headerlink" title="Go数据底层的存储"></a>Go数据底层的存储</h3><p> 介绍 <a target="_blank" rel="noopener" href="http://research.swtch.com/godata">Go数据结构</a> 的文章</p>
<p> <img src="https://z3.ax1x.com/2021/11/09/IJXrfs.png" alt="Go数据格式的存储"></p>
<h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a>分组声明</h3><p> 在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明。如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;os&quot;</span><br><span class="line"></span><br><span class="line">const i = 100</span><br><span class="line">const pi = 3.1415</span><br><span class="line">const prefix = &quot;Go_&quot;</span><br><span class="line"></span><br><span class="line">var i int</span><br><span class="line">var pi float32</span><br><span class="line">var prefix string</span><br></pre></td></tr></table></figure><br> 可分组写成如下形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const(</span><br><span class="line">	i = 100</span><br><span class="line">	pi = 3.1415</span><br><span class="line">	prefix = &quot;Go_&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var(</span><br><span class="line">	i int</span><br><span class="line">	pi float32</span><br><span class="line">	prefix string</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="iota枚举"><a href="#iota枚举" class="headerlink" title="iota枚举"></a>iota枚举</h3><p> Go里面有一个关键字iota，这个关键字用来声明enum的时候采用，它默认开始值是0，const中每增加一行加1：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	x = iota // x == 0</span><br><span class="line">	y = iota // y == 1</span><br><span class="line">	z = iota // z == 2</span><br><span class="line">	w        // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	h, i, j = iota, iota, iota //h=0,i=0,j=0 iota在同一行值相同</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	a       = iota //a=0</span><br><span class="line">	b       = &quot;B&quot;</span><br><span class="line">	c       = iota             //c=2</span><br><span class="line">	d, e, f = iota, iota, iota //d=3,e=3,f=3</span><br><span class="line">	g       = iota             //g = 4</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>除非被显式设置为其它值或iota，每个const分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是iota，则它也被设置为iota。</p>
</blockquote>
<h3 id="Go程序设计的一些规则"><a href="#Go程序设计的一些规则" class="headerlink" title="Go程序设计的一些规则"></a>Go程序设计的一些规则</h3><p> Go之所以会那么简洁，是因为它有一些默认的行为：</p>
<ul>
<li>大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。</li>
</ul>
<ul>
<li>大写字母开头的函数也是一样，相当于class中的带public关键词的公有函数；小写字母开头的就是有private关键词的私有函数。</li>
</ul>
<hr>
<h3 id="array、slice、map"><a href="#array、slice、map" class="headerlink" title="array、slice、map"></a>array、slice、map</h3><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p> array就是数组，它的定义方式如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr [n]type</span><br></pre></td></tr></table></figure><br> 在[n]type中，n表示数组的长度，type表示存储元素的类型。对数组的操作和其它语言类似，都是通过[]来进行读取或赋值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr [10]int  // 声明了一个int类型的数组</span><br><span class="line">arr[0] = 42      // 数组下标是从0开始的</span><br><span class="line">arr[1] = 13      // 赋值操作</span><br><span class="line">fmt.Printf(&quot;The first element is %d\n&quot;, arr[0])  // 获取数据，返回42</span><br><span class="line">fmt.Printf(&quot;The last element is %d\n&quot;, arr[9]) //返回未赋值的最后一个元素，默认返回0</span><br></pre></td></tr></table></figure><br> 由于长度也是数组类型的一部分，因此[3]int与[4]int是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的slice类型了。<br> 数组可以使用另一种:=来声明<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := [3]int&#123;1, 2, 3&#125; // 声明了一个长度为3的int数组</span><br><span class="line">b := [10]int&#123;1, 2, 3&#125; // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0</span><br><span class="line">c := [...]int&#123;4, 5, 6&#125; // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度</span><br></pre></td></tr></table></figure><br> Go支持嵌套数组，即多维数组。比如下面的代码就声明了一个二维数组：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span><br><span class="line">doubleArray := [2][4]int&#123;[4]int&#123;1, 2, 3, 4&#125;, [4]int&#123;5, 6, 7, 8&#125;&#125;</span><br><span class="line">// 上面的声明可以简化，直接忽略内部的类型</span><br><span class="line">easyArray := [2][4]int&#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;&#125;</span><br></pre></td></tr></table></figure><br> 数组的分配如下所示：<br> <img src="https://z3.ax1x.com/2021/11/09/IJXDYj.png" alt="多维数组的映射关系"></p>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p> 在很多应用场景中，数组并不能满足我们的需求。在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫slice。slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 和声明array一样，只是少了长度</span><br><span class="line">var fslice []int</span><br></pre></td></tr></table></figure>
<p> 接下来我们可以声明一个slice，并初始化数据，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []byte &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p> slice可以从一个数组或一个已经存在的slice中再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个含有10个元素元素类型为byte的数组</span><br><span class="line">var ar = [10]byte &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;&#125;</span><br><span class="line"></span><br><span class="line">// 声明两个含有byte的slice</span><br><span class="line">var a, b []byte</span><br><span class="line"></span><br><span class="line">// a指向数组的第3个元素开始，并到第五个元素结束，</span><br><span class="line">a = ar[2:5]</span><br><span class="line">//现在a含有的元素: ar[2]、ar[3]和ar[4]</span><br><span class="line"></span><br><span class="line">// b是数组ar的另一个slice</span><br><span class="line">b = ar[3:5]</span><br><span class="line">// b的元素是：ar[3]和ar[4]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意slice和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用…自动计算长度，而声明slice时，方括号内没有任何字符。</p>
</blockquote>
<p> 它们的数据结构如下所示:<br> <img src="https://z3.ax1x.com/2021/11/09/IJXBkQ.png" alt="slice和array的对应关系图"></p>
<p><strong>slice还有一些简便的操作：</strong></p>
<ul>
<li>slice的默认开始位置是0，ar[:n]等价于ar[0:n]</li>
</ul>
<ul>
<li>slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]</li>
</ul>
<ul>
<li>如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]<br>下面这个例子展示了更多关于slice的操作：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个数组</span><br><span class="line">var array = [10]byte&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;&#125;</span><br><span class="line">// 声明两个slice</span><br><span class="line">var aSlice, bSlice []byte</span><br><span class="line">// 演示一些简便操作</span><br><span class="line">aSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span><br><span class="line">aSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span><br><span class="line">aSlice = array[:]  // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span><br><span class="line">// 从slice中获取slice</span><br><span class="line">aSlice = array[3:7]  // aSlice包含元素: d,e,f,g，len=4，cap=7</span><br><span class="line">bSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span><br><span class="line">bSlice = aSlice[:3]  // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span><br><span class="line">bSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span><br><span class="line">bSlice = aSlice[:]   // bSlice包含所有aSlice的元素: d,e,f,g</span><br></pre></td></tr></table></figure>
<p> slice是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的aSlice和bSlice，如果修改了aSlice中元素的值，那么bSlice相对应的值也会改变。</p>
<p> 从概念上面来说slice像一个结构体，这个结构体包含了三个元素：</p>
<ul>
<li>一个指针，指向数组中slice指定的开始位置</li>
</ul>
<ul>
<li>长度，即slice的长度</li>
</ul>
<ul>
<li>最大长度，也就是slice开始位置到数组的最后位置的长度</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array_a := [10]byte&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;&#125;</span><br><span class="line">Slice_a := Array_a[2:5]</span><br></pre></td></tr></table></figure>
<p> 上面所示代码真正存储结构如下图所示：<br><img src="https://z3.ax1x.com/2021/11/09/IJXwTg.png" alt="slice对应数组的信息"></p>
<p><strong>对于slice有几个有用的内置函数：</strong></p>
<ul>
<li>len获取slice的长度</li>
</ul>
<ul>
<li>cap获取slice的最大容量</li>
</ul>
<ul>
<li>append向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice</li>
</ul>
<ul>
<li>copy函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数</li>
</ul>
<blockquote>
<p>注：append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩余空间（即 <em>(cap-len) == 0</em> 时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响。</p>
</blockquote>
<p> 从Go1.2开始slice支持了三个参数的slice，之前我们一直采用这种方式在slice或者array基础上来获取一个slice</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array [10]int</span><br><span class="line">slice := array[2:4]</span><br></pre></td></tr></table></figure>
<p> 这个例子里面slice的容量是8，新版本里面可以指定这个容量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice = array[2:4:7]</span><br></pre></td></tr></table></figure>
<p> 上面这个的容量就是7-2，即5。这样这个产生的新的slice就没办法访问最后的三个元素。 如果slice是这样的形式array[:i:j]，即第一个参数为空，默认值就是0。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p> map也就是Python中字典的概念，它的格式为map[keyType]valueType</p>
<p> map的读取和设置也类似slice一样，通过key来操作，只是slice的index只能是｀int｀类型，而map多了很多类型，可以是int，可以是string及所有完全定义了==与!=操作的类型。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化</span><br><span class="line">var numbers map[string]int</span><br><span class="line">// 另一种map的声明方式</span><br><span class="line">numbers = make(map[string]int)</span><br><span class="line">numbers[&quot;one&quot;] = 1  //赋值</span><br><span class="line">numbers[&quot;ten&quot;] = 10 //赋值</span><br><span class="line">numbers[&quot;three&quot;] = 3</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;第三个数字是: &quot;, numbers[&quot;three&quot;]) // 读取数据</span><br><span class="line">// 打印出来如:第三个数字是: 3</span><br></pre></td></tr></table></figure><br> 左边列是key，右边列是值</p>
<p> <strong>使用map过程中需要注意的几点:</strong></p>
<ul>
<li>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取</li>
</ul>
<ul>
<li>map的长度是不固定的，也就是和slice一样，也是一种引用类型</li>
</ul>
<ul>
<li>内置的len函数同样适用于map，返回map拥有的key的数量</li>
</ul>
<ul>
<li>map的值可以很方便的修改，通过numbers[“one”]=11可以很容易的把key为one的字典值改为11</li>
</ul>
<ul>
<li><p>map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</p>
<p>map的初始化可以通过key:val的方式初始化值，同时map内置有判断是否存在key的方式</p>
<p>通过delete删除map的元素：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化一个字典</span><br><span class="line">rating := map[string]float32&#123;&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 &#125;</span><br><span class="line">// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true</span><br><span class="line">csharpRating, ok := rating[&quot;C#&quot;]</span><br><span class="line">if ok &#123;</span><br><span class="line">	fmt.Println(&quot;C# is in the map and its rating is &quot;, csharpRating)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fmt.Println(&quot;We have no rating associated with C# in the map&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete(rating, &quot;C&quot;)  // 删除key为C的元素</span><br></pre></td></tr></table></figure>
<p> map也是一种引用类型，如果两个map同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := make(map[string]string)</span><br><span class="line">m[&quot;Hello&quot;] = &quot;Bonjour&quot;</span><br><span class="line">m1 := m</span><br><span class="line">m1[&quot;Hello&quot;] = &quot;Salut&quot;  // 现在m[&quot;hello&quot;]的值已经是Salut了</span><br></pre></td></tr></table></figure>
<h3 id="make、new操作"><a href="#make、new操作" class="headerlink" title="make、new操作"></a>make、new操作</h3><p> make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。</p>
<p> 内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：</p>
<blockquote>
<p>new返回指针。</p>
</blockquote>
<p> 内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值。</p>
<blockquote>
<p>make返回初始化后的（非零）值。</p>
</blockquote>
<p> 下面这个图详细的解释了new和make之间的区别:<br><img src="https://z3.ax1x.com/2021/11/10/IUPIzT.png" alt="make和new对应底层的内存分配"></p>
<h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p> 关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。此处罗列部分类型的“零值”<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int     0</span><br><span class="line">int8    0</span><br><span class="line">int32   0</span><br><span class="line">int64   0</span><br><span class="line">uint    0x0</span><br><span class="line">rune    0 //rune的实际类型是 int32</span><br><span class="line">byte    0x0 // byte的实际类型是 uint8</span><br><span class="line">float32 0 //长度为 4 byte</span><br><span class="line">float64 0 //长度为 8 byte</span><br><span class="line">bool    false</span><br><span class="line">string  &quot;&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="流程和控制"><a href="#流程和控制" class="headerlink" title="流程和控制"></a>流程和控制</h1><p> 介绍Go的流程控制及函数操作</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p> Go里面if条件判断语句中不需要括号，如下代码所示:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if x &gt; 10 &#123;</span><br><span class="line">	fmt.Println(&quot;x is greater than 10&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fmt.Println(&quot;x is less than 10&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> Go的if还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 计算获取值x,然后根据x返回的大小，判断是否大于10。</span><br><span class="line">if x := computedValue(); x &gt; 10 &#123;</span><br><span class="line">	fmt.Println(&quot;x is greater than 10&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fmt.Println(&quot;x is less than 10&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个地方如果这样调用就编译出错了，因为x是条件里面的变量</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure><br> 多条件如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if integer == 3 &#123;</span><br><span class="line">	fmt.Println(&quot;The integer is equal to 3&quot;)</span><br><span class="line">&#125; else if integer &lt; 3 &#123;</span><br><span class="line">	fmt.Println(&quot;The integer is less than 3&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fmt.Println(&quot;The integer is greater than 3&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p> goto跳转到必须在当前函数内定义的标签。例如假设这样一个循环：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func myFunc() &#123;</span><br><span class="line">	i := 0</span><br><span class="line">Here:   //这行的第一个词，以冒号结束作为标签</span><br><span class="line">	println(i)</span><br><span class="line">	i++</span><br><span class="line">	goto Here   //跳转到Here去</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>标签名是大小写敏感的。</p>
</blockquote>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p> for是Go里面最强大的一个控制逻辑，它既可以用来循环读取数据，又可以当作while来控制逻辑，还能迭代操作。语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for expression1; expression2; expression3 &#123;</span><br><span class="line">	//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>expression都是表达式；expression1，expression3：变量声明或函数调用返回值之类；expression2：用来条件判断；expression1在循环开始之前调用，expression3在每轮循环结束之时调用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	sum := 0;</span><br><span class="line">	for index:=0; index &lt; 10 ; index++ &#123;</span><br><span class="line">		sum += index</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;sum is equal to &quot;, sum)</span><br><span class="line">&#125;</span><br><span class="line">// 输出：sum is equal to 45</span><br></pre></td></tr></table></figure>
<p> 有些时候需要进行多个赋值操作，由于Go里面没有,操作符，那么可以使用平行赋值i, j = i+1, j-1</p>
<p> 有些时候如果我们忽略expression1和expression3：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := 1</span><br><span class="line">for ; sum &lt; 1000;  &#123;</span><br><span class="line">	sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 其中;也可以省略，那么就变成如下的代码了，是不是似曾相识？对，这就是while的功能。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := 1</span><br><span class="line">for sum &lt; 1000 &#123;</span><br><span class="line">	sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在循环里面有两个关键操作break和continue ,break操作是跳出当前循环，continue是跳过本次循环。当嵌套过深的时候，break可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for index := 10; index&gt;0; index-- &#123;</span><br><span class="line">	if index == 5&#123;</span><br><span class="line">		break // 或者continue</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(index)</span><br><span class="line">&#125;</span><br><span class="line">// break打印出来10、9、8、7、6</span><br><span class="line">// continue打印出来10、9、8、7、6、4、3、2、1</span><br></pre></td></tr></table></figure><br> break和continue还可以跟着标号，用来跳到多重循环中的外层循环</p>
<p> for配合range可以用于读取slice和map的数据：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for k,v:=range map &#123;</span><br><span class="line">	fmt.Println(&quot;map&#x27;s key:&quot;,k)</span><br><span class="line">	fmt.Println(&quot;map&#x27;s val:&quot;,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用_来丢弃不需要的返回值 例如<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, v := range map&#123;</span><br><span class="line">	fmt.Println(&quot;map&#x27;s val:&quot;, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p> 有些时候你需要写很多的if-else来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候switch就能很好的解决这个问题。它的语法如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch sExpr &#123;</span><br><span class="line">case expr1:</span><br><span class="line">	some instructions</span><br><span class="line">case expr2:</span><br><span class="line">	some other instructions</span><br><span class="line">case expr3:</span><br><span class="line">	some other instructions</span><br><span class="line">default:</span><br><span class="line">	other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> sExpr和expr1、expr2、expr3的类型必须一致。Go的switch非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果switch没有表达式，它会匹配true。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i := 10</span><br><span class="line">switch i &#123;</span><br><span class="line">case 1:</span><br><span class="line">	fmt.Println(&quot;i is equal to 1&quot;)</span><br><span class="line">case 2, 3, 4:</span><br><span class="line">	fmt.Println(&quot;i is equal to 2, 3 or 4&quot;)</span><br><span class="line">case 10:</span><br><span class="line">	fmt.Println(&quot;i is equal to 10&quot;)</span><br><span class="line">default:</span><br><span class="line">	fmt.Println(&quot;All I know is that i is an integer&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在第5行中，我们把很多值聚合在了一个case里面，同时，Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">integer := 6</span><br><span class="line">switch integer &#123;</span><br><span class="line">case 4:</span><br><span class="line">	fmt.Println(&quot;The integer was &lt;= 4&quot;)</span><br><span class="line">	fallthrough</span><br><span class="line">case 5:</span><br><span class="line">	fmt.Println(&quot;The integer was &lt;= 5&quot;)</span><br><span class="line">	fallthrough</span><br><span class="line">case 6:</span><br><span class="line">	fmt.Println(&quot;The integer was &lt;= 6&quot;)</span><br><span class="line">	fallthrough</span><br><span class="line">case 7:</span><br><span class="line">	fmt.Println(&quot;The integer was &lt;= 7&quot;)</span><br><span class="line">	fallthrough</span><br><span class="line">case 8:</span><br><span class="line">	fmt.Println(&quot;The integer was &lt;= 8&quot;)</span><br><span class="line">	fallthrough</span><br><span class="line">default:</span><br><span class="line">	fmt.Println(&quot;default case&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 上面的程序将输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The integer was &lt;= 6</span><br><span class="line">The integer was &lt;= 7</span><br><span class="line">The integer was &lt;= 8</span><br><span class="line">default case</span><br></pre></td></tr></table></figure></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p> 函数是Go里面的核心设计，它通过关键字func来声明，它的格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) &#123;</span><br><span class="line">	//这里是处理逻辑代码</span><br><span class="line">	//返回多个值</span><br><span class="line">	return value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 上面的代码我们看出:</p>
<ul>
<li>关键字func用来声明一个函数funcName</li>
</ul>
<ul>
<li>函数可以有一个或者多个参数，每个参数后面带有类型，通过,分隔</li>
</ul>
<ul>
<li>函数可以返回多个值</li>
</ul>
<ul>
<li>上面返回值声明了两个变量output1和output2，如果你不想声明也可以，直接就两个类型</li>
</ul>
<ul>
<li>如果只有一个返回值且不声明返回值变量，那么你可以省略 包括返回值 的括号</li>
</ul>
<ul>
<li>如果没有返回值，那么就直接省略最后的返回信息</li>
</ul>
<ul>
<li><p>如果有返回值， 那么必须在函数的外层添加return语句<br>下面我们来看一个实际应用函数的例子（用来计算Max值）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 返回a、b中最大值.</span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">	if a &gt; b &#123;</span><br><span class="line">		return a</span><br><span class="line">	&#125;</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	x := 3</span><br><span class="line">	y := 4</span><br><span class="line">	z := 5</span><br><span class="line"></span><br><span class="line">	max_xy := max(x, y) //调用函数max(x, y)</span><br><span class="line">	max_xz := max(x, z) //调用函数max(x, z)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;max(%d, %d) = %d\n&quot;, x, y, max_xy)</span><br><span class="line">	fmt.Printf(&quot;max(%d, %d) = %d\n&quot;, x, z, max_xz)</span><br><span class="line">	fmt.Printf(&quot;max(%d, %d) = %d\n&quot;, y, z, max(y,z)) // 也可在这直接调用它</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到max函数有两个参数，它们的类型都是int，那么第一个变量的类型可以省略（即 a,b int,而非 a int, b int)，默认为离它最近的类型，同理多于2个同类型的变量或者返回值。同时我们注意到它的返回值就是一个类型，这个就是省略写法。</p>
<h3 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h3><p>Go语言比C更先进的特性，其中一点就是函数能够返回多个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//返回 A+B 和 A*B</span><br><span class="line">func SumAndProduct(A, B int) (int, int) &#123;</span><br><span class="line">	return A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	x := 3</span><br><span class="line">	y := 4</span><br><span class="line"></span><br><span class="line">	xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;%d + %d = %d\n&quot;, x, y, xPLUSy)</span><br><span class="line">	fmt.Printf(&quot;%d * %d = %d\n&quot;, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子我们可以看到直接返回了两个参数，当然我们也可以命名返回参数的变量，这个例子里面只是用了两个类型，我们也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果你的函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func SumAndProduct(A, B int) (add int, Multiplied int) &#123;</span><br><span class="line">	add = A+B</span><br><span class="line">	Multiplied = A*B</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h3><p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func myfunc(arg ...int) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>arg …int告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是int。在函数体中，变量arg是一个int的slice：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, n := range arg &#123;</span><br><span class="line">	fmt.Printf(&quot;And the number is: %d\n&quot;, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传值与传指针"><a href="#传值与传指针" class="headerlink" title="传值与传指针"></a>传值与传指针</h3><p>当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。为了验证我们上面的说法，我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//简单的一个函数，实现了参数+1的操作</span><br><span class="line">func add1(a int) int &#123;</span><br><span class="line">	a = a+1 // 我们改变了a的值</span><br><span class="line">	return a //返回一个新值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	x := 3</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;x = &quot;, x)  // 应该输出 &quot;x = 3&quot;</span><br><span class="line"></span><br><span class="line">	x1 := add1(x)  //调用add1(x)</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;x+1 = &quot;, x1) // 应该输出&quot;x+1 = 4&quot;</span><br><span class="line">	fmt.Println(&quot;x = &quot;, x)    // 应该输出&quot;x = 3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然我们调用了add1函数，并且在add1中执行a = a+1操作，但是上面例子中x变量的值没有发生变化，理由很简单：因为当我们调用add1的时候，add1接收的参数其实是x的copy，而不是x本身。</p>
<p>如果真的需要传这个x本身,该怎么办呢？</p>
<p>这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有add1函数知道x变量所在的地址，才能修改x变量的值。所以我们需要将x所在地址&amp;x传入函数，并将函数的参数的类型由int改为*int，即改为指针类型，才能在函数中修改x变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//简单的一个函数，实现了参数+1的操作</span><br><span class="line">func add1(a *int) int &#123; // 请注意，</span><br><span class="line">	*a = *a+1 // 修改了a的值</span><br><span class="line">	return *a // 返回新值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	x := 3</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;x = &quot;, x)  // 应该输出 &quot;x = 3&quot;</span><br><span class="line"></span><br><span class="line">	x1 := add1(&amp;x)  // 调用 add1(&amp;x) 传x的地址</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;x+1 = &quot;, x1) // 应该输出 &quot;x+1 = 4&quot;</span><br><span class="line">	fmt.Println(&quot;x = &quot;, x)    // 应该输出 &quot;x = 4&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，就达到了修改x的目的。传指针的好处如下：</p>
</li>
<li>传指针使得多个函数能操作同一个对象。</li>
</ul>
<ul>
<li>传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。</li>
</ul>
<ul>
<li>Go语言中channel，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）</li>
</ul>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p> Go语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func ReadWrite() bool &#123;</span><br><span class="line">	file.Open(&quot;file&quot;)</span><br><span class="line">// 做一些工作</span><br><span class="line">	if failureX &#123;</span><br><span class="line">		file.Close()</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if failureY &#123;</span><br><span class="line">		file.Close()</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	file.Close()</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 我们看到上面有很多重复的代码，Go的defer有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在defer后指定的函数会在函数退出前调用。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func ReadWrite() bool &#123;</span><br><span class="line">	file.Open(&quot;file&quot;)</span><br><span class="line">	defer file.Close()</span><br><span class="line">	if failureX &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	if failureY &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 如果有很多调用defer，那么defer是采用后进先出模式，所以如下代码会输出4 3 2 1 0<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">	defer fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数作为值、类型"><a href="#函数作为值、类型" class="headerlink" title="函数作为值、类型"></a>函数作为值、类型</h3><p> 在Go中函数也是一种变量，我们可以通过type来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...])</span><br></pre></td></tr></table></figure><br> 函数作为类型到底有什么好处呢？那就是<em>可以把这个类型的函数当做值来传递</em>，请看下面的例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type testInt func(int) bool // 声明了一个函数类型</span><br><span class="line"></span><br><span class="line">func isOdd(integer int) bool &#123;</span><br><span class="line">	if integer%2 == 0 &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isEven(integer int) bool &#123;</span><br><span class="line">	if integer%2 == 0 &#123;</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line">	return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明的函数类型在这个地方当做了一个参数</span><br><span class="line"></span><br><span class="line">func filter(slice []int, f testInt) []int &#123;</span><br><span class="line">	var result []int</span><br><span class="line">	for _, value := range slice &#123;</span><br><span class="line">		if f(value) &#123;</span><br><span class="line">			result = append(result, value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	slice := []int &#123;1, 2, 3, 4, 5, 7&#125;</span><br><span class="line">	fmt.Println(&quot;slice = &quot;, slice)</span><br><span class="line">	odd := filter(slice, isOdd)    // 函数当做值来传递了</span><br><span class="line">	fmt.Println(&quot;Odd elements of slice are: &quot;, odd)</span><br><span class="line">	even := filter(slice, isEven)  // 函数当做值来传递了</span><br><span class="line">	fmt.Println(&quot;Even elements of slice are: &quot;, even)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="学习参考资料"><a href="#学习参考资料" class="headerlink" title="学习参考资料"></a>学习参考资料</h1><ul>
<li><img src="http://tour.studygolang.com/flowcontrol/1" alt="Go指南"></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rxov</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rxvo.github.io/post/go.html">https://rxvo.github.io/post/go.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rxvo.github.io" target="_blank">Live Your Life</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638856406&amp;t=f2a64ef1b887e37b9d00add7521ea926" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/imgg/wechat.JPG" target="_blank"><img class="post-qr-code-img" src="/imgg/wechat.JPG" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/imgg/alipay.JPG" target="_blank"><img class="post-qr-code-img" src="/imgg/alipay.JPG" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/post/post1.html"><img class="next-cover" src="https://pic2.zhimg.com/v2-bf39215f40fc816eb497816eedfbe345_1440w.jpg?source=172ae18b" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Learning to Group and Label Fine-Grained Shape Components</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://z3.ax1x.com/2021/05/14/gymhKH.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Rxov</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RXvo" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1286623452@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.coolapk.com/apk/com.qjhcqaq.icons" target="_blank" title="Coolapk"><i class="fab fa-uncharted"></i></a><a class="social-icon" href="https://www.zhihu.com/people/bai-yin-3" target="_blank" title="知乎"><i class="fab fa-zhihu"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">河流从不催促过河的人。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">安装配置相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">关键点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">Go语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%94%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.</span> <span class="toc-text">二十五个关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">定义变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.4.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">内置基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean"><span class="toc-number">2.5.1.</span> <span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">数值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.3.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E6%95%B0%E6%8D%AE%E5%BA%95%E5%B1%82%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">2.5.4.</span> <span class="toc-text">Go数据底层的存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7"><span class="toc-number">2.6.</span> <span class="toc-text">一些技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.6.1.</span> <span class="toc-text">分组声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iota%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.6.2.</span> <span class="toc-text">iota枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%99"><span class="toc-number">2.6.3.</span> <span class="toc-text">Go程序设计的一些规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array%E3%80%81slice%E3%80%81map"><span class="toc-number">2.6.4.</span> <span class="toc-text">array、slice、map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#array"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slice"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">slice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-number">2.6.4.3.</span> <span class="toc-text">map</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make%E3%80%81new%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.5.</span> <span class="toc-text">make、new操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E5%80%BC"><span class="toc-number">2.7.</span> <span class="toc-text">零值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%92%8C%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">流程和控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-number">3.1.1.</span> <span class="toc-text">if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goto"><span class="toc-number">3.1.2.</span> <span class="toc-text">goto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-number">3.1.3.</span> <span class="toc-text">for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">3.1.4.</span> <span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.2.1.</span> <span class="toc-text">多个返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E5%8F%82"><span class="toc-number">3.2.2.</span> <span class="toc-text">变参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC%E4%B8%8E%E4%BC%A0%E6%8C%87%E9%92%88"><span class="toc-number">3.2.3.</span> <span class="toc-text">传值与传指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-number">3.2.4.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%80%BC%E3%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.5.</span> <span class="toc-text">函数作为值、类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">学习参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/go.html" title="Go's Learning"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638856406&amp;t=f2a64ef1b887e37b9d00add7521ea926" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go's Learning"/></a><div class="content"><a class="title" href="/post/go.html" title="Go's Learning">Go's Learning</a><time datetime="2021-11-07T05:40:37.000Z" title="发表于 2021-11-07 13:40:37">2021-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/post1.html" title="Learning to Group and Label Fine-Grained Shape Components"><img src="https://pic2.zhimg.com/v2-bf39215f40fc816eb497816eedfbe345_1440w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Learning to Group and Label Fine-Grained Shape Components"/></a><div class="content"><a class="title" href="/post/post1.html" title="Learning to Group and Label Fine-Grained Shape Components">Learning to Group and Label Fine-Grained Shape Components</a><time datetime="2021-11-05T13:18:45.000Z" title="发表于 2021-11-05 21:18:45">2021-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/position.html" title="姿态角与四元数"><img src="https://z3.ax1x.com/2021/11/05/Iut68x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="姿态角与四元数"/></a><div class="content"><a class="title" href="/post/position.html" title="姿态角与四元数">姿态角与四元数</a><time datetime="2021-11-05T12:59:45.000Z" title="发表于 2021-11-05 20:59:45">2021-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/python.html" title="Python 基础 + 数据可视化"><img src="https://www.hualigs.cn/image/60a0e62b8a821.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 基础 + 数据可视化"/></a><div class="content"><a class="title" href="/post/python.html" title="Python 基础 + 数据可视化">Python 基础 + 数据可视化</a><time datetime="2021-11-04T09:59:45.000Z" title="发表于 2021-11-04 17:59:45">2021-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/machine-learning.html" title="《Python 深度学习》笔记"><img src="https://www.hualigs.cn/image/60a0e62b10935.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Python 深度学习》笔记"/></a><div class="content"><a class="title" href="/post/machine-learning.html" title="《Python 深度学习》笔记">《Python 深度学习》笔记</a><time datetime="2021-11-04T08:59:45.000Z" title="发表于 2021-11-04 16:59:45">2021-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Rxov</div><div class="footer_custom_text">Hi, welcome to my <a href="www.baidu.com">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'DqMfrFMV57n1pOhaVzDoGfwx-MdYXbMMI',
      appKey: '86wdpP7iC3kdGTRlTEoC8mvR',
      placeholder: '记得留下你的昵称和邮箱....可以快速收到回复',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>(function(d, w, c) {
    w.ChatraID = '6dEMJKyRkc64Swf7G';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>