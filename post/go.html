<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go's Learning | Live Your Life</title><meta name="keywords" content="Golang"><meta name="author" content="Rxov"><meta name="copyright" content="Rxov"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Golang的学习之路">
<meta property="og:type" content="article">
<meta property="og:title" content="Go&#39;s Learning">
<meta property="og:url" content="https://rxvo.github.io/post/go.html">
<meta property="og:site_name" content="Live Your Life">
<meta property="og:description" content="Golang的学习之路">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&refer=http%3A%2F%2Fi2.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1638856406&t=f2a64ef1b887e37b9d00add7521ea926">
<meta property="article:published_time" content="2021-11-07T05:40:37.000Z">
<meta property="article:modified_time" content="2021-12-01T01:00:27.643Z">
<meta property="article:author" content="Rxov">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&refer=http%3A%2F%2Fi2.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1638856406&t=f2a64ef1b887e37b9d00add7521ea926"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rxvo.github.io/post/go"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8586c99fd6df25e156703e50b90263bb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go\'s Learning',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-01 09:00:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/footers.css"><link rel="stylesheet" href="/css/Lete.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://z3.ax1x.com/2021/05/14/gymhKH.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-video"></i><span> 微语</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638856406&amp;t=f2a64ef1b887e37b9d00add7521ea926')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Live Your Life</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-video"></i><span> 微语</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go's Learning</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-07T05:40:37.000Z" title="发表于 2021-11-07 13:40:37">2021-11-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-01T01:00:27.643Z" title="更新于 2021-12-01 09:00:27">2021-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Go%E8%AF%AD%E8%A8%80/">Go语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Go's Learning"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/go.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/go.html" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="安装配置相关"><a href="#安装配置相关" class="headerlink" title="安装配置相关"></a>安装配置相关</h1><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><p> 配置Go mod镜像（使用VSCode）解决导包FAILED的问题</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.4.md">主要参考1</a></li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45914985/article/details/109555913?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=vs%E9%85%8D%E7%BD%AEgo&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-109555913.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187">主要参考2</a></li>
</ul>
<h1 id="Go语言基础"><a href="#Go语言基础" class="headerlink" title="Go语言基础"></a>Go语言基础</h1><h2 id="二十五个关键字"><a href="#二十五个关键字" class="headerlink" title="二十五个关键字"></a>二十五个关键字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break    default      func    interface    select</span><br><span class="line">case     defer        go      map          struct</span><br><span class="line">chan     else         goto    package      switch</span><br><span class="line">const    fallthrough  if      range        type</span><br><span class="line">continue for          import  return       var</span><br></pre></td></tr></table></figure>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p> Go使用package（和Python的模块类似）来组织代码。main.main()函数(这个函数位于主包）是每一个独立的可运行程序的入口点。Go使用UTF-8字符串和标识符(因为UTF-8的发明者也就是Go的发明者之一)，所以它天生支持多语言。</p>
<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p> 使用var关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面：<br> 单变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量</span><br><span class="line">var variableName type</span><br></pre></td></tr></table></figure><br> 多变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//定义三个类型都是“type”的变量</span><br><span class="line">var vname1, vname2, vname3 type</span><br></pre></td></tr></table></figure><br> 定义变量并初始化值:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//初始化“variableName”的变量为“value”值，类型是“type”</span><br><span class="line">var variableName type = value</span><br></pre></td></tr></table></figure><br> 同时初始化多个变量:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">	定义三个变量，它们分别初始化为相应的值</span><br><span class="line">	vname1为v1，vname2为v2，vname3为v3</span><br><span class="line">	然后Go会根据其相应值的类型来帮你初始化它们</span><br><span class="line">*/</span><br><span class="line">var vname1, vname2, vname3 = v1, v2, v3</span><br></pre></td></tr></table></figure><br> 简化方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">	定义三个变量，它们分别初始化为相应的值</span><br><span class="line">	vname1为v1，vname2为v2，vname3为v3</span><br><span class="line">	编译器会根据初始化的值自动推导出相应的类型</span><br><span class="line">*/</span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure><br> :=这个符号直接取代了var和type,这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用var方式来定义全局变量。</p>
<p> Go对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了i但未使用;<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var i int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p> 在Go程序中，常量可定义为数值、布尔值或字符串等类型。<br> 用法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const constantName = value</span><br><span class="line">//如果需要，也可以明确指定常量的类型：</span><br><span class="line">const Pi float32 = 3.1415926</span><br></pre></td></tr></table></figure><br> Go常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)， 若指定給float32自动缩短为32bit，指定给float64自动缩短为64bit，详情参考<a target="_blank" rel="noopener" href="http://golang.org/ref/spec#Constants">链接</a></p>
<h2 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p> 在Go中，布尔值的类型为bool，值是true或false，默认为false。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//示例代码</span><br><span class="line">var isActive bool  // 全局变量声明</span><br><span class="line">var enabled, disabled = true, false  // 忽略类型的声明</span><br><span class="line">func test() &#123;</span><br><span class="line">	var available bool  // 一般声明</span><br><span class="line">	valid := false      // 简短声明</span><br><span class="line">	available = true    // 赋值操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p> Go里面也有直接定义好位数的类型：rune, int8, int16, int32, int64和byte, uint8, uint16, uint32, uint64。<br> 浮点数的类型有float32和float64两种（没有float类型），默认是float64。此外还支持复数。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p> Go中的字符串都是采用UTF-8字符集编码。字符串是用一对双引号（””）或反引号（<code> </code>）括起来定义，它的类型是string。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//示例代码</span><br><span class="line">var frenchHello string  // 声明变量为字符串的一般方法</span><br><span class="line">var emptyString string = &quot;&quot;  // 声明了一个字符串变量，初始化为空字符串</span><br><span class="line">func test() &#123;</span><br><span class="line">	no, yes, maybe := &quot;no&quot;, &quot;yes&quot;, &quot;maybe&quot;  // 简短声明，同时声明多个变量</span><br><span class="line">	japaneseHello := &quot;Konichiwa&quot;  // 同上</span><br><span class="line">	frenchHello = &quot;Bonjour&quot;  // 常规赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s string = &quot;hello&quot;</span><br><span class="line">s[0] = &#x27;c&#x27;</span><br></pre></td></tr></table></figure><br> 想要修改可以使用下面代码实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;hello&quot;</span><br><span class="line">c := []byte(s)  // 将字符串 s 转换为 []byte 类型</span><br><span class="line">c[0] = &#x27;c&#x27;</span><br><span class="line">s2 := string(c)  // 再转换回 string 类型</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, s2)</span><br></pre></td></tr></table></figure><br> Go中可以使用+操作符来连接两个字符串：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;hello,&quot;</span><br><span class="line">m := &quot; world&quot;</span><br><span class="line">a := s + m</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, a)</span><br></pre></td></tr></table></figure><br> 修改字符串也可写为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;hello&quot;</span><br><span class="line">s = &quot;c&quot; + s[1:] // 字符串虽不能更改，但可进行切片操作</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, s)</span><br></pre></td></tr></table></figure></p>
<h3 id="Go数据底层的存储"><a href="#Go数据底层的存储" class="headerlink" title="Go数据底层的存储"></a>Go数据底层的存储</h3><p> 介绍 <a target="_blank" rel="noopener" href="http://research.swtch.com/godata">Go数据结构</a> 的文章</p>
<p> <img src="https://z3.ax1x.com/2021/11/09/IJXrfs.png" alt="Go数据格式的存储"></p>
<h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a>分组声明</h3><p> 在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明。如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;os&quot;</span><br><span class="line"></span><br><span class="line">const i = 100</span><br><span class="line">const pi = 3.1415</span><br><span class="line">const prefix = &quot;Go_&quot;</span><br><span class="line"></span><br><span class="line">var i int</span><br><span class="line">var pi float32</span><br><span class="line">var prefix string</span><br></pre></td></tr></table></figure><br> 可分组写成如下形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const(</span><br><span class="line">	i = 100</span><br><span class="line">	pi = 3.1415</span><br><span class="line">	prefix = &quot;Go_&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var(</span><br><span class="line">	i int</span><br><span class="line">	pi float32</span><br><span class="line">	prefix string</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="iota枚举"><a href="#iota枚举" class="headerlink" title="iota枚举"></a>iota枚举</h3><p> Go里面有一个关键字iota，这个关键字用来声明enum的时候采用，它默认开始值是0，const中每增加一行加1：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	x = iota // x == 0</span><br><span class="line">	y = iota // y == 1</span><br><span class="line">	z = iota // z == 2</span><br><span class="line">	w        // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	h, i, j = iota, iota, iota //h=0,i=0,j=0 iota在同一行值相同</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	a       = iota //a=0</span><br><span class="line">	b       = &quot;B&quot;</span><br><span class="line">	c       = iota             //c=2</span><br><span class="line">	d, e, f = iota, iota, iota //d=3,e=3,f=3</span><br><span class="line">	g       = iota             //g = 4</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>除非被显式设置为其它值或iota，每个const分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是iota，则它也被设置为iota。</p>
</blockquote>
<h3 id="Go程序设计的一些规则"><a href="#Go程序设计的一些规则" class="headerlink" title="Go程序设计的一些规则"></a>Go程序设计的一些规则</h3><p> Go之所以会那么简洁，是因为它有一些默认的行为：</p>
<ul>
<li>大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。</li>
</ul>
<ul>
<li>大写字母开头的函数也是一样，相当于class中的带public关键词的公有函数；小写字母开头的就是有private关键词的私有函数。</li>
</ul>
<hr>
<h3 id="array、slice、map"><a href="#array、slice、map" class="headerlink" title="array、slice、map"></a>array、slice、map</h3><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p> array就是数组，它的定义方式如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr [n]type</span><br></pre></td></tr></table></figure><br> 在[n]type中，n表示数组的长度，type表示存储元素的类型。对数组的操作和其它语言类似，都是通过[]来进行读取或赋值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr [10]int  // 声明了一个int类型的数组</span><br><span class="line">arr[0] = 42      // 数组下标是从0开始的</span><br><span class="line">arr[1] = 13      // 赋值操作</span><br><span class="line">fmt.Printf(&quot;The first element is %d\n&quot;, arr[0])  // 获取数据，返回42</span><br><span class="line">fmt.Printf(&quot;The last element is %d\n&quot;, arr[9]) //返回未赋值的最后一个元素，默认返回0</span><br></pre></td></tr></table></figure><br> 由于长度也是数组类型的一部分，因此[3]int与[4]int是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的slice类型了。<br> 数组可以使用另一种:=来声明<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := [3]int&#123;1, 2, 3&#125; // 声明了一个长度为3的int数组</span><br><span class="line">b := [10]int&#123;1, 2, 3&#125; // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0</span><br><span class="line">c := [...]int&#123;4, 5, 6&#125; // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度</span><br></pre></td></tr></table></figure><br> Go支持嵌套数组，即多维数组。比如下面的代码就声明了一个二维数组：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span><br><span class="line">doubleArray := [2][4]int&#123;[4]int&#123;1, 2, 3, 4&#125;, [4]int&#123;5, 6, 7, 8&#125;&#125;</span><br><span class="line">// 上面的声明可以简化，直接忽略内部的类型</span><br><span class="line">easyArray := [2][4]int&#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;&#125;</span><br></pre></td></tr></table></figure><br> 数组的分配如下所示：<br> <img src="https://z3.ax1x.com/2021/11/09/IJXDYj.png" alt="多维数组的映射关系"></p>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p> 在很多应用场景中，数组并不能满足我们的需求。在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫slice。slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 和声明array一样，只是少了长度</span><br><span class="line">var fslice []int</span><br></pre></td></tr></table></figure>
<p> 接下来我们可以声明一个slice，并初始化数据，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []byte &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p> slice可以从一个数组或一个已经存在的slice中再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个含有10个元素元素类型为byte的数组</span><br><span class="line">var ar = [10]byte &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;&#125;</span><br><span class="line"></span><br><span class="line">// 声明两个含有byte的slice</span><br><span class="line">var a, b []byte</span><br><span class="line"></span><br><span class="line">// a指向数组的第3个元素开始，并到第五个元素结束，</span><br><span class="line">a = ar[2:5]</span><br><span class="line">//现在a含有的元素: ar[2]、ar[3]和ar[4]</span><br><span class="line"></span><br><span class="line">// b是数组ar的另一个slice</span><br><span class="line">b = ar[3:5]</span><br><span class="line">// b的元素是：ar[3]和ar[4]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意slice和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用…自动计算长度，而声明slice时，方括号内没有任何字符。</p>
</blockquote>
<p> 它们的数据结构如下所示:<br> <img src="https://z3.ax1x.com/2021/11/09/IJXBkQ.png" alt="slice和array的对应关系图"></p>
<p><strong>slice还有一些简便的操作：</strong></p>
<ul>
<li>slice的默认开始位置是0，ar[:n]等价于ar[0:n]</li>
</ul>
<ul>
<li>slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]</li>
</ul>
<ul>
<li>如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]<br>下面这个例子展示了更多关于slice的操作：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个数组</span><br><span class="line">var array = [10]byte&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;&#125;</span><br><span class="line">// 声明两个slice</span><br><span class="line">var aSlice, bSlice []byte</span><br><span class="line">// 演示一些简便操作</span><br><span class="line">aSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span><br><span class="line">aSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span><br><span class="line">aSlice = array[:]  // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span><br><span class="line">// 从slice中获取slice</span><br><span class="line">aSlice = array[3:7]  // aSlice包含元素: d,e,f,g，len=4，cap=7</span><br><span class="line">bSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span><br><span class="line">bSlice = aSlice[:3]  // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span><br><span class="line">bSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span><br><span class="line">bSlice = aSlice[:]   // bSlice包含所有aSlice的元素: d,e,f,g</span><br></pre></td></tr></table></figure>
<p> slice是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的aSlice和bSlice，如果修改了aSlice中元素的值，那么bSlice相对应的值也会改变。</p>
<p> 从概念上面来说slice像一个结构体，这个结构体包含了三个元素：</p>
<ul>
<li>一个指针，指向数组中slice指定的开始位置</li>
</ul>
<ul>
<li>长度，即slice的长度</li>
</ul>
<ul>
<li>最大长度，也就是slice开始位置到数组的最后位置的长度</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array_a := [10]byte&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;&#125;</span><br><span class="line">Slice_a := Array_a[2:5]</span><br></pre></td></tr></table></figure>
<p> 上面所示代码真正存储结构如下图所示：<br><img src="https://z3.ax1x.com/2021/11/09/IJXwTg.png" alt="slice对应数组的信息"></p>
<p><strong>对于slice有几个有用的内置函数：</strong></p>
<ul>
<li>len获取slice的长度</li>
</ul>
<ul>
<li>cap获取slice的最大容量</li>
</ul>
<ul>
<li>append向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice</li>
</ul>
<ul>
<li>copy函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数</li>
</ul>
<blockquote>
<p>注：append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩余空间（即 <em>(cap-len) == 0</em> 时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响。</p>
</blockquote>
<p> 从Go1.2开始slice支持了三个参数的slice，之前我们一直采用这种方式在slice或者array基础上来获取一个slice</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array [10]int</span><br><span class="line">slice := array[2:4]</span><br></pre></td></tr></table></figure>
<p> 这个例子里面slice的容量是8，新版本里面可以指定这个容量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice = array[2:4:7]</span><br></pre></td></tr></table></figure>
<p> 上面这个的容量就是7-2，即5。这样这个产生的新的slice就没办法访问最后的三个元素。 如果slice是这样的形式array[:i:j]，即第一个参数为空，默认值就是0。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p> map也就是Python中字典的概念，它的格式为map[keyType]valueType</p>
<p> map的读取和设置也类似slice一样，通过key来操作，只是slice的index只能是｀int｀类型，而map多了很多类型，可以是int，可以是string及所有完全定义了==与!=操作的类型。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化</span><br><span class="line">var numbers map[string]int</span><br><span class="line">// 另一种map的声明方式</span><br><span class="line">numbers = make(map[string]int)</span><br><span class="line">numbers[&quot;one&quot;] = 1  //赋值</span><br><span class="line">numbers[&quot;ten&quot;] = 10 //赋值</span><br><span class="line">numbers[&quot;three&quot;] = 3</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;第三个数字是: &quot;, numbers[&quot;three&quot;]) // 读取数据</span><br><span class="line">// 打印出来如:第三个数字是: 3</span><br></pre></td></tr></table></figure><br> 左边列是key，右边列是值</p>
<p> <strong>使用map过程中需要注意的几点:</strong></p>
<ul>
<li>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取</li>
</ul>
<ul>
<li>map的长度是不固定的，也就是和slice一样，也是一种引用类型</li>
</ul>
<ul>
<li>内置的len函数同样适用于map，返回map拥有的key的数量</li>
</ul>
<ul>
<li>map的值可以很方便的修改，通过numbers[“one”]=11可以很容易的把key为one的字典值改为11</li>
</ul>
<ul>
<li><p>map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</p>
<p>map的初始化可以通过key:val的方式初始化值，同时map内置有判断是否存在key的方式</p>
<p>通过delete删除map的元素：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化一个字典</span><br><span class="line">rating := map[string]float32&#123;&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 &#125;</span><br><span class="line">// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true</span><br><span class="line">csharpRating, ok := rating[&quot;C#&quot;]</span><br><span class="line">if ok &#123;</span><br><span class="line">	fmt.Println(&quot;C# is in the map and its rating is &quot;, csharpRating)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fmt.Println(&quot;We have no rating associated with C# in the map&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete(rating, &quot;C&quot;)  // 删除key为C的元素</span><br></pre></td></tr></table></figure>
<p> map也是一种引用类型，如果两个map同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := make(map[string]string)</span><br><span class="line">m[&quot;Hello&quot;] = &quot;Bonjour&quot;</span><br><span class="line">m1 := m</span><br><span class="line">m1[&quot;Hello&quot;] = &quot;Salut&quot;  // 现在m[&quot;hello&quot;]的值已经是Salut了</span><br></pre></td></tr></table></figure>
<h3 id="make、new操作"><a href="#make、new操作" class="headerlink" title="make、new操作"></a>make、new操作</h3><p> make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。</p>
<p> 内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：</p>
<blockquote>
<p>new返回指针。</p>
</blockquote>
<p> 内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值。</p>
<blockquote>
<p>make返回初始化后的（非零）值。</p>
</blockquote>
<p> 下面这个图详细的解释了new和make之间的区别:<br><img src="https://z3.ax1x.com/2021/11/10/IUPIzT.png" alt="make和new对应底层的内存分配"></p>
<h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p> 关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。此处罗列部分类型的“零值”<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int     0</span><br><span class="line">int8    0</span><br><span class="line">int32   0</span><br><span class="line">int64   0</span><br><span class="line">uint    0x0</span><br><span class="line">rune    0 //rune的实际类型是 int32</span><br><span class="line">byte    0x0 // byte的实际类型是 uint8</span><br><span class="line">float32 0 //长度为 4 byte</span><br><span class="line">float64 0 //长度为 8 byte</span><br><span class="line">bool    false</span><br><span class="line">string  &quot;&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="流程和函数"><a href="#流程和函数" class="headerlink" title="流程和函数"></a>流程和函数</h1><p> 介绍Go的流程控制及函数操作</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p> Go里面if条件判断语句中不需要括号，如下代码所示:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if x &gt; 10 &#123;</span><br><span class="line">	fmt.Println(&quot;x is greater than 10&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fmt.Println(&quot;x is less than 10&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> Go的if还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 计算获取值x,然后根据x返回的大小，判断是否大于10。</span><br><span class="line">if x := computedValue(); x &gt; 10 &#123;</span><br><span class="line">	fmt.Println(&quot;x is greater than 10&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fmt.Println(&quot;x is less than 10&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个地方如果这样调用就编译出错了，因为x是条件里面的变量</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure><br> 多条件如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if integer == 3 &#123;</span><br><span class="line">	fmt.Println(&quot;The integer is equal to 3&quot;)</span><br><span class="line">&#125; else if integer &lt; 3 &#123;</span><br><span class="line">	fmt.Println(&quot;The integer is less than 3&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fmt.Println(&quot;The integer is greater than 3&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p> goto跳转到必须在当前函数内定义的标签。例如假设这样一个循环：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func myFunc() &#123;</span><br><span class="line">	i := 0</span><br><span class="line">Here:   //这行的第一个词，以冒号结束作为标签</span><br><span class="line">	println(i)</span><br><span class="line">	i++</span><br><span class="line">	goto Here   //跳转到Here去</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>标签名是大小写敏感的。</p>
</blockquote>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p> for是Go里面最强大的一个控制逻辑，它既可以用来循环读取数据，又可以当作while来控制逻辑，还能迭代操作。语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for expression1; expression2; expression3 &#123;</span><br><span class="line">	//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>expression都是表达式；expression1，expression3：变量声明或函数调用返回值之类；expression2：用来条件判断；expression1在循环开始之前调用，expression3在每轮循环结束之时调用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	sum := 0;</span><br><span class="line">	for index:=0; index &lt; 10 ; index++ &#123;</span><br><span class="line">		sum += index</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;sum is equal to &quot;, sum)</span><br><span class="line">&#125;</span><br><span class="line">// 输出：sum is equal to 45</span><br></pre></td></tr></table></figure>
<p> 有些时候需要进行多个赋值操作，由于Go里面没有,操作符，那么可以使用平行赋值i, j = i+1, j-1</p>
<p> 有些时候如果我们忽略expression1和expression3：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := 1</span><br><span class="line">for ; sum &lt; 1000;  &#123;</span><br><span class="line">	sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 其中;也可以省略，那么就变成如下的代码了，是不是似曾相识？对，这就是while的功能。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := 1</span><br><span class="line">for sum &lt; 1000 &#123;</span><br><span class="line">	sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在循环里面有两个关键操作break和continue ,break操作是跳出当前循环，continue是跳过本次循环。当嵌套过深的时候，break可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for index := 10; index&gt;0; index-- &#123;</span><br><span class="line">	if index == 5&#123;</span><br><span class="line">		break // 或者continue</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(index)</span><br><span class="line">&#125;</span><br><span class="line">// break打印出来10、9、8、7、6</span><br><span class="line">// continue打印出来10、9、8、7、6、4、3、2、1</span><br></pre></td></tr></table></figure><br> break和continue还可以跟着标号，用来跳到多重循环中的外层循环</p>
<p> for配合range可以用于读取slice和map的数据：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for k,v:=range map &#123;</span><br><span class="line">	fmt.Println(&quot;map&#x27;s key:&quot;,k)</span><br><span class="line">	fmt.Println(&quot;map&#x27;s val:&quot;,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用_来丢弃不需要的返回值 例如<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, v := range map&#123;</span><br><span class="line">	fmt.Println(&quot;map&#x27;s val:&quot;, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p> 有些时候你需要写很多的if-else来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候switch就能很好的解决这个问题。它的语法如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch sExpr &#123;</span><br><span class="line">case expr1:</span><br><span class="line">	some instructions</span><br><span class="line">case expr2:</span><br><span class="line">	some other instructions</span><br><span class="line">case expr3:</span><br><span class="line">	some other instructions</span><br><span class="line">default:</span><br><span class="line">	other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> sExpr和expr1、expr2、expr3的类型必须一致。Go的switch非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果switch没有表达式，它会匹配true。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i := 10</span><br><span class="line">switch i &#123;</span><br><span class="line">case 1:</span><br><span class="line">	fmt.Println(&quot;i is equal to 1&quot;)</span><br><span class="line">case 2, 3, 4:</span><br><span class="line">	fmt.Println(&quot;i is equal to 2, 3 or 4&quot;)</span><br><span class="line">case 10:</span><br><span class="line">	fmt.Println(&quot;i is equal to 10&quot;)</span><br><span class="line">default:</span><br><span class="line">	fmt.Println(&quot;All I know is that i is an integer&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在第5行中，我们把很多值聚合在了一个case里面，同时，Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">integer := 6</span><br><span class="line">switch integer &#123;</span><br><span class="line">case 4:</span><br><span class="line">	fmt.Println(&quot;The integer was &lt;= 4&quot;)</span><br><span class="line">	fallthrough</span><br><span class="line">case 5:</span><br><span class="line">	fmt.Println(&quot;The integer was &lt;= 5&quot;)</span><br><span class="line">	fallthrough</span><br><span class="line">case 6:</span><br><span class="line">	fmt.Println(&quot;The integer was &lt;= 6&quot;)</span><br><span class="line">	fallthrough</span><br><span class="line">case 7:</span><br><span class="line">	fmt.Println(&quot;The integer was &lt;= 7&quot;)</span><br><span class="line">	fallthrough</span><br><span class="line">case 8:</span><br><span class="line">	fmt.Println(&quot;The integer was &lt;= 8&quot;)</span><br><span class="line">	fallthrough</span><br><span class="line">default:</span><br><span class="line">	fmt.Println(&quot;default case&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 上面的程序将输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The integer was &lt;= 6</span><br><span class="line">The integer was &lt;= 7</span><br><span class="line">The integer was &lt;= 8</span><br><span class="line">default case</span><br></pre></td></tr></table></figure></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p> 函数是Go里面的核心设计，它通过关键字func来声明，它的格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) &#123;</span><br><span class="line">	//这里是处理逻辑代码</span><br><span class="line">	//返回多个值</span><br><span class="line">	return value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 上面的代码我们看出:</p>
<ul>
<li>关键字func用来声明一个函数funcName</li>
</ul>
<ul>
<li>函数可以有一个或者多个参数，每个参数后面带有类型，通过,分隔</li>
</ul>
<ul>
<li>函数可以返回多个值</li>
</ul>
<ul>
<li>上面返回值声明了两个变量output1和output2，如果你不想声明也可以，直接就两个类型</li>
</ul>
<ul>
<li>如果只有一个返回值且不声明返回值变量，那么你可以省略 包括返回值 的括号</li>
</ul>
<ul>
<li>如果没有返回值，那么就直接省略最后的返回信息</li>
</ul>
<ul>
<li><p>如果有返回值， 那么必须在函数的外层添加return语句<br>下面我们来看一个实际应用函数的例子（用来计算Max值）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 返回a、b中最大值.</span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">	if a &gt; b &#123;</span><br><span class="line">		return a</span><br><span class="line">	&#125;</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	x := 3</span><br><span class="line">	y := 4</span><br><span class="line">	z := 5</span><br><span class="line"></span><br><span class="line">	max_xy := max(x, y) //调用函数max(x, y)</span><br><span class="line">	max_xz := max(x, z) //调用函数max(x, z)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;max(%d, %d) = %d\n&quot;, x, y, max_xy)</span><br><span class="line">	fmt.Printf(&quot;max(%d, %d) = %d\n&quot;, x, z, max_xz)</span><br><span class="line">	fmt.Printf(&quot;max(%d, %d) = %d\n&quot;, y, z, max(y,z)) // 也可在这直接调用它</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到max函数有两个参数，它们的类型都是int，那么第一个变量的类型可以省略（即 a,b int,而非 a int, b int)，默认为离它最近的类型，同理多于2个同类型的变量或者返回值。同时我们注意到它的返回值就是一个类型，这个就是省略写法。</p>
<h3 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h3><p>Go语言比C更先进的特性，其中一点就是函数能够返回多个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//返回 A+B 和 A*B</span><br><span class="line">func SumAndProduct(A, B int) (int, int) &#123;</span><br><span class="line">	return A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	x := 3</span><br><span class="line">	y := 4</span><br><span class="line"></span><br><span class="line">	xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;%d + %d = %d\n&quot;, x, y, xPLUSy)</span><br><span class="line">	fmt.Printf(&quot;%d * %d = %d\n&quot;, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子我们可以看到直接返回了两个参数，当然我们也可以命名返回参数的变量，这个例子里面只是用了两个类型，我们也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果你的函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func SumAndProduct(A, B int) (add int, Multiplied int) &#123;</span><br><span class="line">	add = A+B</span><br><span class="line">	Multiplied = A*B</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h3><p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func myfunc(arg ...int) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>arg …int告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是int。在函数体中，变量arg是一个int的slice：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, n := range arg &#123;</span><br><span class="line">	fmt.Printf(&quot;And the number is: %d\n&quot;, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传值与传指针"><a href="#传值与传指针" class="headerlink" title="传值与传指针"></a>传值与传指针</h3><p>当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。为了验证我们上面的说法，我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//简单的一个函数，实现了参数+1的操作</span><br><span class="line">func add1(a int) int &#123;</span><br><span class="line">	a = a+1 // 我们改变了a的值</span><br><span class="line">	return a //返回一个新值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	x := 3</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;x = &quot;, x)  // 应该输出 &quot;x = 3&quot;</span><br><span class="line"></span><br><span class="line">	x1 := add1(x)  //调用add1(x)</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;x+1 = &quot;, x1) // 应该输出&quot;x+1 = 4&quot;</span><br><span class="line">	fmt.Println(&quot;x = &quot;, x)    // 应该输出&quot;x = 3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然我们调用了add1函数，并且在add1中执行a = a+1操作，但是上面例子中x变量的值没有发生变化，理由很简单：因为当我们调用add1的时候，add1接收的参数其实是x的copy，而不是x本身。</p>
<p>如果真的需要传这个x本身,该怎么办呢？</p>
<p>这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有add1函数知道x变量所在的地址，才能修改x变量的值。所以我们需要将x所在地址&amp;x传入函数，并将函数的参数的类型由int改为*int，即改为指针类型，才能在函数中修改x变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//简单的一个函数，实现了参数+1的操作</span><br><span class="line">func add1(a *int) int &#123; // 请注意，</span><br><span class="line">	*a = *a+1 // 修改了a的值</span><br><span class="line">	return *a // 返回新值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	x := 3</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;x = &quot;, x)  // 应该输出 &quot;x = 3&quot;</span><br><span class="line"></span><br><span class="line">	x1 := add1(&amp;x)  // 调用 add1(&amp;x) 传x的地址</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;x+1 = &quot;, x1) // 应该输出 &quot;x+1 = 4&quot;</span><br><span class="line">	fmt.Println(&quot;x = &quot;, x)    // 应该输出 &quot;x = 4&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型 <em>T 是指向 T 类型值的指针，其零值为 nil; &amp; 操作符会生成一个指向其操作数的指针; </em> 操作符表示指针指向的底层值。</p>
<p>这样，就达到了修改x的目的。传指针的好处如下：</p>
</li>
<li>传指针使得多个函数能操作同一个对象。</li>
</ul>
<ul>
<li>传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。</li>
</ul>
<ul>
<li>Go语言中channel，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）</li>
</ul>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p> Go语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func ReadWrite() bool &#123;</span><br><span class="line">	file.Open(&quot;file&quot;)</span><br><span class="line">// 做一些工作</span><br><span class="line">	if failureX &#123;</span><br><span class="line">		file.Close()</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if failureY &#123;</span><br><span class="line">		file.Close()</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	file.Close()</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 我们看到上面有很多重复的代码，Go的defer有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在defer后指定的函数会在函数退出前调用。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func ReadWrite() bool &#123;</span><br><span class="line">	file.Open(&quot;file&quot;)</span><br><span class="line">	defer file.Close()</span><br><span class="line">	if failureX &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	if failureY &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用，所以如下代码会输出4 3 2 1 0<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">	defer fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数作为值、类型"><a href="#函数作为值、类型" class="headerlink" title="函数作为值、类型"></a>函数作为值、类型</h3><p> 在Go中函数也是一种变量，我们可以通过type来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...])</span><br></pre></td></tr></table></figure><br> 函数作为类型到底有什么好处呢？那就是<em>可以把这个类型的函数当做值来传递</em>，请看下面的例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type testInt func(int) bool // 声明了一个函数类型</span><br><span class="line"></span><br><span class="line">func isOdd(integer int) bool &#123;</span><br><span class="line">	if integer%2 == 0 &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isEven(integer int) bool &#123;</span><br><span class="line">	if integer%2 == 0 &#123;</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line">	return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明的函数类型在这个地方当做了一个参数</span><br><span class="line"></span><br><span class="line">func filter(slice []int, f testInt) []int &#123;</span><br><span class="line">	var result []int</span><br><span class="line">	for _, value := range slice &#123;</span><br><span class="line">		if f(value) &#123;</span><br><span class="line">			result = append(result, value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	slice := []int &#123;1, 2, 3, 4, 5, 7&#125;</span><br><span class="line">	fmt.Println(&quot;slice = &quot;, slice)</span><br><span class="line">	odd := filter(slice, isOdd)    // 函数当做值来传递了</span><br><span class="line">	fmt.Println(&quot;Odd elements of slice are: &quot;, odd)</span><br><span class="line">	even := filter(slice, isEven)  // 函数当做值来传递了</span><br><span class="line">	fmt.Println(&quot;Even elements of slice are: &quot;, even)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 函数当做值和类型在我们写一些通用接口的时候非常有用，通过上面例子我们看到testInt这个类型是一个函数类型，然后两个filter函数的参数和返回值与testInt类型是一样的，但是我们可以实现很多种的逻辑，这样使得我们的程序变得非常的灵活。</p>
<h3 id="Panic和Recover"><a href="#Panic和Recover" class="headerlink" title="Panic和Recover"></a>Panic和Recover</h3><p> Go没有像Java那样的异常机制，它不能抛出异常，而是使用了panic和recover机制。一定要记住，你应当把它作为最后的手段来使用，也就是说，你的代码中应当没有，或者很少有panic的东西。这是个强大的工具，请明智地使用它。</p>
<p><strong>Panic</strong></p>
<blockquote>
<p>是一个内建函数，可以中断原有的控制流程，进入一个panic状态中。当函数F调用panic，函数F的执行被中断，但是F中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，F的行为就像调用了panic。这一过程继续向上，直到发生panic的goroutine中所有调用的函数返回，此时程序退出。panic可以直接调用panic产生。也可以由运行时错误产生，例如访问越界的数组。</p>
</blockquote>
<p><strong>Recover</strong></p>
<blockquote>
<p>是一个内建的函数，可以让进入panic状态的goroutine恢复过来。recover仅在延迟函数中有效。在正常的执行过程中，调用recover会返回nil，并且没有其它任何效果。如果当前的goroutine陷入panic状态，调用recover可以捕获到panic的输入值，并且恢复正常的执行。</p>
</blockquote>
<p> 下面这个函数演示了如何在过程中使用panic:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var user = os.Getenv(&quot;USER&quot;)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">	if user == &quot;&quot; &#123;</span><br><span class="line">		panic(&quot;no value for $USER&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 下面这个函数检查作为其参数的函数在执行时是否会产生panic：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func throwsPanic(f func()) (b bool) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		if x := recover(); x != nil &#123;</span><br><span class="line">			b = true</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	f() //执行函数f，如果f中出现了panic，那么就可以恢复回来</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="main函数和init函数"><a href="#main函数和init函数" class="headerlink" title="main函数和init函数"></a>main函数和init函数</h3><p> Go里面有两个保留的函数：init函数（能够应用于所有的<code>package</code>）和<code>main</code>函数（只能应用于<code>package main</code>）。这两个函数在定义时不能有任何的参数和返回值。虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个<code>package</code>中每个文件只写一个<code>init</code>函数。</p>
<p> Go程序会自动调用<code>init()</code>和<code>main()</code>，所以你不需要在任何地方调用这两个函数。每个<code>package</code>中的<code>init</code>函数都是可选的，但<code>package main</code>就必须包含一个main函数。</p>
<p> 程序的初始化和执行都起始于<code>main</code>包。如果<code>main</code>包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到<code>fmt</code>包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行<code>init</code>函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行<code>main</code>包中的<code>init</code>函数（如果存在的话），最后执行<code>main</code>函数。下图详细地解释了整个执行过程：</p>
<p><img src="https://z3.ax1x.com/2021/11/22/IvXTbj.png" alt="main函数引入包初始化流程图"></p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p> 写Go代码的时候经常用到<code>import</code>这个命令用来导入包文件，而我们经常看到的方式参考如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br> 然后我们代码里面可以通过如下的方式调用:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure><br> 上面展示了一些<code>import</code>常用的几种方式，但是还有一些特殊的<code>import</code>，例如：</p>
<p>1.点操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">    . &quot;fmt&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p> 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的<code>fmt.Println(&quot;hello world&quot;)</code>可以省略的写成<code>Println(&quot;hello world&quot;)</code></p>
<p>2.别名操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">    f &quot;fmt&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p> 别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字,调用包函数时前缀变成了我们的前缀，即f.Println(“hello world”)</p>
<p>3._操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;database/sql&quot;</span><br><span class="line">    _ &quot;github.com/ziutek/mymysql/godrv&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p> _操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。</p>
<h1 id="struct类型"><a href="#struct类型" class="headerlink" title="struct类型"></a>struct类型</h1><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p> Go语言中，也和C或者其他语言一样，我们可以声明新的类型，作为其它类型的属性或字段的容器。例如，我们可以创建一个自定义类型<code>person</code>代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型我们称之<code>struct</code>。如下代码所示:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 声明一个struct很简单，上面的类型包含有两个字段：</p>
<ul>
<li>一个string类型的字段name，用来保存用户名称这个属性</li>
</ul>
<ul>
<li>一个int类型的字段age,用来保存用户年龄这个属性</li>
</ul>
<p>关于struct的使用请看下面的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var P person  // P现在就是person类型的变量了</span><br><span class="line"></span><br><span class="line">P.name = &quot;Astaxie&quot;  // 赋值&quot;Astaxie&quot;给P的name属性.</span><br><span class="line">P.age = 25  // 赋值&quot;25&quot;给变量P的age属性</span><br><span class="line">fmt.Printf(&quot;The person&#x27;s name is %s&quot;, P.name)  // 访问P的name属性.</span><br></pre></td></tr></table></figure><br> 除了上面这种P的声明使用之外，还有另外几种声明使用方式：</p>
<ul>
<li><p>按照顺序提供初始化值</p>
<p><code>P := person&#123;&quot;Tom&quot;, 25&#125;</code></p>
</li>
</ul>
<ul>
<li><p>通过<code>field:value</code>的方式初始化，这样可以任意顺序</p>
<p><code>P := person&#123;age:24, name:&quot;Tom&quot;&#125;</code></p>
</li>
</ul>
<ul>
<li><p>当然也可以通过<code>new</code>函数分配一个指针，此处P的类型为<code>*person</code></p>
<p><code>P := new(person)</code></p>
</li>
</ul>
<p>下面看一个完整的使用struct的例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 声明一个新的类型</span><br><span class="line">type person struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差</span><br><span class="line">// struct也是传值的</span><br><span class="line">func Older(p1, p2 person) (person, int) &#123;</span><br><span class="line">	if p1.age&gt;p2.age &#123;  // 比较p1和p2这两个人的年龄</span><br><span class="line">		return p1, p1.age-p2.age</span><br><span class="line">	&#125;</span><br><span class="line">	return p2, p2.age-p1.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var tom person</span><br><span class="line"></span><br><span class="line">	// 赋值初始化</span><br><span class="line">	tom.name, tom.age = &quot;Tom&quot;, 18</span><br><span class="line"></span><br><span class="line">	// 两个字段都写清楚的初始化</span><br><span class="line">	bob := person&#123;age:25, name:&quot;Bob&quot;&#125;</span><br><span class="line"></span><br><span class="line">	// 按照struct定义顺序初始化值</span><br><span class="line">	paul := person&#123;&quot;Paul&quot;, 43&#125;</span><br><span class="line"></span><br><span class="line">	tb_Older, tb_diff := Older(tom, bob)</span><br><span class="line">	tp_Older, tp_diff := Older(tom, paul)</span><br><span class="line">	bp_Older, bp_diff := Older(bob, paul)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;Of %s and %s, %s is older by %d years\n&quot;,</span><br><span class="line">		tom.name, bob.name, tb_Older.name, tb_diff)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;Of %s and %s, %s is older by %d years\n&quot;,</span><br><span class="line">		tom.name, paul.name, tp_Older.name, tp_diff)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;Of %s and %s, %s is older by %d years\n&quot;,</span><br><span class="line">		bob.name, paul.name, bp_Older.name, bp_diff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="struct的匿名字段"><a href="#struct的匿名字段" class="headerlink" title="struct的匿名字段"></a>struct的匿名字段</h3><p> 上面介绍了如何定义一个<code>struct</code>，定义的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。</p>
<p> 当匿名字段是一个<code>struct</code>的时候，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的这个<code>struct</code>。</p>
<p> 让我们来看一个例子，让上面说的这些更具体化：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">	weight int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">	Human  // 匿名字段，那么默认Student就包含了Human的所有字段</span><br><span class="line">	speciality string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 我们初始化一个学生</span><br><span class="line">	mark := Student&#123;Human&#123;&quot;Mark&quot;, 25, 120&#125;, &quot;Computer Science&quot;&#125;</span><br><span class="line"></span><br><span class="line">	// 我们访问相应的字段</span><br><span class="line">	fmt.Println(&quot;His name is &quot;, mark.name)</span><br><span class="line">	fmt.Println(&quot;His age is &quot;, mark.age)</span><br><span class="line">	fmt.Println(&quot;His weight is &quot;, mark.weight)</span><br><span class="line">	fmt.Println(&quot;His speciality is &quot;, mark.speciality)</span><br><span class="line">	// 修改对应的备注信息</span><br><span class="line">	mark.speciality = &quot;AI&quot;</span><br><span class="line">	fmt.Println(&quot;Mark changed his speciality&quot;)</span><br><span class="line">	fmt.Println(&quot;His speciality is &quot;, mark.speciality)</span><br><span class="line">	// 修改他的年龄信息</span><br><span class="line">	fmt.Println(&quot;Mark become old&quot;)</span><br><span class="line">	mark.age = 46</span><br><span class="line">	fmt.Println(&quot;His age is&quot;, mark.age)</span><br><span class="line">	// 修改他的体重信息</span><br><span class="line">	fmt.Println(&quot;Mark is not an athlet anymore&quot;)</span><br><span class="line">	mark.weight += 60</span><br><span class="line">	fmt.Println(&quot;His weight is&quot;, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 图例如下:</p>
<p><img src="https://z3.ax1x.com/2021/11/22/Izih5D.png" alt="struct组合，Student组合了Human struct和string基本类型"></p>
<p> 我们看到<code>Student</code>访问属性<code>age</code>和<code>name</code>的时候，就像访问自己所有用的字段一样，对，匿名字段就是这样，能够实现字段的继承。比这个更酷的就是<code>student</code>还能访问<code>Human</code>这个字段作为字段名。请看下面的代码，是不是更酷了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mark.Human = Human&#123;&quot;Marcus&quot;, 55, 220&#125;</span><br><span class="line">mark.Human.age -= 1</span><br></pre></td></tr></table></figure><br> 通过匿名访问和修改字段相当的有用，但是不仅仅是struct字段哦，所有的内置类型和自定义类型都是可以作为匿名字段的。请看下面的例子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Skills []string</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">	weight int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">	Human  // 匿名字段，struct</span><br><span class="line">	Skills // 匿名字段，自定义的类型string slice</span><br><span class="line">	int    // 内置类型作为匿名字段</span><br><span class="line">	speciality string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 初始化学生Jane</span><br><span class="line">	jane := Student&#123;Human:Human&#123;&quot;Jane&quot;, 35, 100&#125;, speciality:&quot;Biology&quot;&#125;</span><br><span class="line">	// 现在我们来访问相应的字段</span><br><span class="line">	fmt.Println(&quot;Her name is &quot;, jane.name)</span><br><span class="line">	fmt.Println(&quot;Her age is &quot;, jane.age)</span><br><span class="line">	fmt.Println(&quot;Her weight is &quot;, jane.weight)</span><br><span class="line">	fmt.Println(&quot;Her speciality is &quot;, jane.speciality)</span><br><span class="line">	// 我们来修改他的skill技能字段</span><br><span class="line">	jane.Skills = []string&#123;&quot;anatomy&quot;&#125;</span><br><span class="line">	fmt.Println(&quot;Her skills are &quot;, jane.Skills)</span><br><span class="line">	fmt.Println(&quot;She acquired two new ones &quot;)</span><br><span class="line">	jane.Skills = append(jane.Skills, &quot;physics&quot;, &quot;golang&quot;)</span><br><span class="line">	fmt.Println(&quot;Her skills now are &quot;, jane.Skills)</span><br><span class="line">	// 修改匿名内置类型字段</span><br><span class="line">	jane.int = 3</span><br><span class="line">	fmt.Println(&quot;Her preferred number is&quot;, jane.int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 从上面例子我们看出来struct不仅仅能够将struct作为匿名字段，自定义类型、内置类型都可以作为匿名字段，而且可以在相应的字段上面进行函数操作（如例子中的append）。</p>
<p> 这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？</p>
<p> Go里面很简单的解决了这个问题，最外层的优先访问，也就是当你通过<code>student.phone</code>访问的时候，是访问<code>student</code>里面的字段，而不是<code>human</code>里面的字段。</p>
<p> 这样就允许我们去重载通过匿名字段继承的一些字段，当然如果我们想访问重载后对应匿名类型里面的字段，可以通过匿名字段名来访问。请看下面的例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">	phone string  // Human类型拥有的字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">	Human  // 匿名字段Human</span><br><span class="line">	speciality string</span><br><span class="line">	phone string  // 雇员的phone字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	Bob := Employee&#123;Human&#123;&quot;Bob&quot;, 34, &quot;777-444-XXXX&quot;&#125;, &quot;Designer&quot;, &quot;333-222&quot;&#125;</span><br><span class="line">	fmt.Println(&quot;Bob&#x27;s work phone is:&quot;, Bob.phone)</span><br><span class="line">	// 如果我们要访问Human的phone字段</span><br><span class="line">	fmt.Println(&quot;Bob&#x27;s personal phone is:&quot;, Bob.Human.phone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p> 是否想过函数当作struct的字段一样来处理呢？我们可以看一下函数的另一种形态，带有接收者的函数，称为<code>method</code></p>
<h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p> 假设有这么一个场景，你定义了一个struct叫做长方形，你现在想要计算他的面积，那么按照我们一般的思路应该会用下面的方式来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Rectangle struct &#123;</span><br><span class="line">	width, height float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func area(r Rectangle) float64 &#123;</span><br><span class="line">	return r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r1 := Rectangle&#123;12, 2&#125;</span><br><span class="line">	r2 := Rectangle&#123;9, 4&#125;</span><br><span class="line">	fmt.Println(&quot;Area of r1 is: &quot;, area(r1))</span><br><span class="line">	fmt.Println(&quot;Area of r2 is: &quot;, area(r2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 这段代码可以计算出来长方形的面积，但是area()不是作为Rectangle的方法实现的（类似面向对象里面的方法），而是将Rectangle的对象（如r1,r2）作为参数传入函数计算面积的。</p>
<p> 这样实现当然没有问题咯，但是当需要增加圆形、正方形、五边形甚至其它多边形的时候，你想计算他们的面积的时候怎么办啊？那就只能增加新的函数咯，但是函数名你就必须要跟着换了，变成area_rectangle, area_circle, area_triangle…</p>
<p> 像下图所表示的那样， 椭圆代表函数, 而这些函数并不从属于struct(或者以面向对象的术语来说，并不属于class)，他们是单独存在于struct外围，而非在概念上属于某个struct的。</p>
<p><img src="https://z3.ax1x.com/2021/11/23/oSol9S.png" alt="方法和struct的关系图"></p>
<p> 很显然，这样的实现并不优雅，并且从概念上来说”面积”是”形状”的一个属性，它是属于这个特定的形状的，就像长方形的长和宽一样。</p>
<p> 基于上面的原因所以就有了<code>method</code>的概念，method是附属在一个给定的类型上的，他的语法和函数的声明语法几乎一样，只是在func后面增加了一个receiver(也就是method所依从的主体)。</p>
<p> 用上面提到的形状的例子来说，<code>method area()</code>是依赖于某个形状(比如说Rectangle)来发生作用的。Rectangle.area()的发出者是Rectangle， area()是属于Rectangle的方法，而非一个外围函数。</p>
<p> 更具体地说，Rectangle存在字段 height 和 width, 同时存在方法area(), 这些字段和方法都属于Rectangle。</p>
<p> 用Rob Pike的话来说就是：</p>
<blockquote>
<p>func (r ReceiverType) funcName(parameters) (results)</p>
</blockquote>
<p> method的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (r ReceiverType) funcName(parameters) (results)</span><br></pre></td></tr></table></figure><br> 下面我们用最开始的例子用method来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Rectangle struct &#123;</span><br><span class="line">	width, height float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Circle struct &#123;</span><br><span class="line">	radius float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Rectangle) area() float64 &#123;</span><br><span class="line">	return r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c Circle) area() float64 &#123;</span><br><span class="line">	return c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r1 := Rectangle&#123;12, 2&#125;</span><br><span class="line">	r2 := Rectangle&#123;9, 4&#125;</span><br><span class="line">	c1 := Circle&#123;10&#125;</span><br><span class="line">	c2 := Circle&#123;25&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;Area of r1 is: &quot;, r1.area())</span><br><span class="line">	fmt.Println(&quot;Area of r2 is: &quot;, r2.area())</span><br><span class="line">	fmt.Println(&quot;Area of c1 is: &quot;, c1.area())</span><br><span class="line">	fmt.Println(&quot;Area of c2 is: &quot;, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在使用method的时候重要注意几点:</p>
<ul>
<li>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</li>
</ul>
<ul>
<li>method里面可以访问接收者的字段</li>
</ul>
<ul>
<li><p>调用method通过<code>.</code>访问，就像struct里面访问字段一样</p>
<p>图示如下:</p>
</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/11/23/oSTjd1.png" alt="不同struct的method不同"></p>
<p> 在上例，method area() 分别属于Rectangle和Circle， 于是他们的 Receiver 就变成了Rectangle 和 Circle, 或者说，这个area()方法 是由 Rectangle/Circle 发出的。</p>
<blockquote>
<p>值得说明的一点是，图示中method用虚线标出，意思是此处方法的Receiver是以值传递，而非引用传递，是的，Receiver还可以是指针, 两者的差别在于, 指针作为Receiver会对实例对象的内容发生操作,而普通类型作为Receiver仅仅是以副本作为操作对象,并不对原实例对象发生操作。后文对此会有详细论述。</p>
</blockquote>
<p> 那是不是method只能作用在struct上面呢？当然不是，它可以定义在任何你自定义的类型、内置类型、struct等各种类型上面。这里你是不是有点迷糊了，什么叫自定义类型，自定义类型不就是struct嘛，不是这样的哦，struct只是自定义类型里面一种比较特殊的类型而已，还有其他自定义类型申明，可以通过如下这样的申明来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type typeName typeLiteral</span><br></pre></td></tr></table></figure><br> 下面是这个申明自定义类型的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type ages int</span><br><span class="line"></span><br><span class="line">type money float32</span><br><span class="line"></span><br><span class="line">type months map[string]int</span><br><span class="line"></span><br><span class="line">m := months &#123;</span><br><span class="line">	&quot;January&quot;:31,</span><br><span class="line">	&quot;February&quot;:28,</span><br><span class="line">	...</span><br><span class="line">	&quot;December&quot;:31,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 你可以在自己的代码里面定义有意义的类型，实际上只是一个定义了一个别名,有点类似于c中的typedef，例如上面ages替代了int</p>
<p> 你可以在任何的自定义类型中定义任意多的<code>method</code>，接下来让我们看一个复杂一点的例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">const(</span><br><span class="line">	WHITE = iota //+1</span><br><span class="line">	BLACK</span><br><span class="line">	BLUE</span><br><span class="line">	RED</span><br><span class="line">	YELLOW</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Color byte</span><br><span class="line"></span><br><span class="line">type Box struct &#123;</span><br><span class="line">	width, height, depth float64</span><br><span class="line">	color Color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BoxList []Box //a slice of boxes</span><br><span class="line"></span><br><span class="line">func (b Box) Volume() float64 &#123;</span><br><span class="line">	return b.width * b.height * b.depth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Box) SetColor(c Color) &#123;</span><br><span class="line">	b.color = c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (bl BoxList) BiggestColor() Color &#123;</span><br><span class="line">	v := 0.00</span><br><span class="line">	k := Color(WHITE)</span><br><span class="line">	for _, b := range bl &#123;</span><br><span class="line">		if bv := b.Volume(); bv &gt; v &#123;</span><br><span class="line">			v = bv</span><br><span class="line">			k = b.color</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (bl BoxList) PaintItBlack() &#123;</span><br><span class="line">	for i := range bl &#123;</span><br><span class="line">		bl[i].SetColor(BLACK)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c Color) String() string &#123;</span><br><span class="line">	strings := []string &#123;&quot;WHITE&quot;, &quot;BLACK&quot;, &quot;BLUE&quot;, &quot;RED&quot;, &quot;YELLOW&quot;&#125;</span><br><span class="line">	return strings[c]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	boxes := BoxList &#123;</span><br><span class="line">		Box&#123;4, 4, 4, RED&#125;,</span><br><span class="line">		Box&#123;10, 10, 1, YELLOW&#125;,</span><br><span class="line">		Box&#123;1, 1, 20, BLACK&#125;,</span><br><span class="line">		Box&#123;10, 10, 1, BLUE&#125;,</span><br><span class="line">		Box&#123;10, 30, 1, WHITE&#125;,</span><br><span class="line">		Box&#123;20, 20, 20, YELLOW&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;We have %d boxes in our set\n&quot;, len(boxes))</span><br><span class="line">	fmt.Println(&quot;The volume of the first one is&quot;, boxes[0].Volume(), &quot;cm³&quot;)</span><br><span class="line">	fmt.Println(&quot;The color of the last one is&quot;,boxes[len(boxes)-1].color.String())</span><br><span class="line">	fmt.Println(&quot;The biggest one is&quot;, boxes.BiggestColor().String())</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;Let&#x27;s paint them all black&quot;)</span><br><span class="line">	boxes.PaintItBlack()</span><br><span class="line">	fmt.Println(&quot;The color of the second one is&quot;, boxes[1].color.String())</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;Obviously, now, the biggest one is&quot;, boxes.BiggestColor().String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 上面的代码通过const定义了一些常量，然后定义了一些自定义类型:</p>
<ul>
<li>Color作为byte的别名</li>
</ul>
<ul>
<li>定义了一个struct:Box，含有三个长宽高字段和一个颜色属性</li>
</ul>
<ul>
<li><p>定义了一个slice:BoxList，含有Box</p>
<p>然后以上面的自定义类型为接收者定义了一些method:</p>
</li>
<li>Volume()定义了接收者为Box，返回Box的容量</li>
</ul>
<ul>
<li>SetColor(c Color)，把Box的颜色改为c</li>
</ul>
<ul>
<li>BiggestColor()定在在BoxList上面，返回list里面容量最大的颜色</li>
</ul>
<ul>
<li>PaintItBlack()把BoxList里面所有Box的颜色全部变成黑色</li>
</ul>
<ul>
<li>String()定义在Color上面，返回Color的具体颜色(字符串格式)</li>
</ul>
<h3 id="指针作为receiver"><a href="#指针作为receiver" class="headerlink" title="指针作为receiver"></a>指针作为receiver</h3><p> 现在让我们回过头来看看SetColor这个method，它的receiver是一个指向Box的指针，是的，你可以使用*Box。想想为什么要使用指针而不是Box本身呢？</p>
<p> 我们定义SetColor的真正目的是想改变这个Box的颜色，如果不传Box的指针，那么SetColor接受的其实是Box的一个copy，也就是说method内对于颜色值的修改，其实只作用于Box的copy，而不是真正的Box。所以我们需要传入指针。</p>
<p> 这里可以把receiver当作method的第一个参数来看，然后结合前面函数讲解的传值和传引用就不难理解</p>
<p> 这里你也许会问了那SetColor函数里面应该这样定义<code>*b.Color=c</code>,而不是<code>b.Color=c</code>,因为我们需要读取到指针相应的值。</p>
<p> 你是对的，其实Go里面这两种方式都是正确的，当你用指针去访问相应的字段时(虽然指针没有任何的字段)，Go知道你要通过指针去获取这个值，看到了吧，Go的设计是不是越来越吸引你了。</p>
<p> 也许细心的读者会问这样的问题，PaintItBlack里面调用SetColor的时候是不是应该写成<code>(&amp;bl[i]).SetColor(BLACK)</code>，因为SetColor的receiver是*Box，而不是Box。</p>
<p> 你又说对了，这两种方式都可以，因为Go知道receiver是指针，他自动帮你转了。</p>
<p> 也就是说：</p>
<blockquote>
<p>如果一个method的receiver是*T,你可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method</p>
</blockquote>
<p> 类似的</p>
<blockquote>
<p>如果一个method的receiver是T，你可以在一个<em>T类型的变量P上面调用这个method，而不需要 </em>P去调用这个method</p>
</blockquote>
<h3 id="method继承"><a href="#method继承" class="headerlink" title="method继承"></a>method继承</h3><p> method也是可以继承的。如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method。让我们来看下面这个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">	phone string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">	Human //匿名字段</span><br><span class="line">	school string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">	Human //匿名字段</span><br><span class="line">	company string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在human上面定义了一个method</span><br><span class="line">func (h *Human) SayHi() &#123;</span><br><span class="line">	fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;&quot;Mark&quot;, 25, &quot;222-222-YYYY&quot;&#125;, &quot;MIT&quot;&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;&quot;Sam&quot;, 45, &quot;111-888-XXXX&quot;&#125;, &quot;Golang Inc&quot;&#125;</span><br><span class="line"></span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="method重写"><a href="#method重写" class="headerlink" title="method重写"></a>method重写</h3><p> 上面的例子中，如果Employee想要实现自己的SayHi,怎么办？很简单，和匿名字段冲突一样的道理，我们可以在Employee上面定义一个method，重写了匿名字段的方法。请看下面的例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">	phone string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">	Human //匿名字段</span><br><span class="line">	school string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">	Human //匿名字段</span><br><span class="line">	company string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Human定义method</span><br><span class="line">func (h *Human) SayHi() &#123;</span><br><span class="line">	fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Employee的method重写Human的method</span><br><span class="line">func (e *Employee) SayHi() &#123;</span><br><span class="line">	fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;, e.name,</span><br><span class="line">		e.company, e.phone) //Yes you can split into 2 lines here.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;&quot;Mark&quot;, 25, &quot;222-222-YYYY&quot;&#125;, &quot;MIT&quot;&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;&quot;Sam&quot;, 45, &quot;111-888-XXXX&quot;&#125;, &quot;Golang Inc&quot;&#125;</span><br><span class="line"></span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 通过这些内容，我们可以设计出基本的面向对象的程序了，但是Go里面的面向对象是如此的简单，没有任何的私有、公有关键字，通过大小写来实现(大写开头的为公有，小写开头的为私有)，方法也同样适用这个原则。</p>
<h1 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h1><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p> Go语言里面设计最精妙的应该算interface，它让面向对象、内容组织实现的非常方便，当你看完这一幕，你就会被interface的精妙所折服。</p>
<h3 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h3><p> 简单的说，interface是一组method签名的组合，我们通过interface来定义对象的一组行为。</p>
<p> 我们前面一章最后一个例子中Student和Employee都能SayHi，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能say hi</p>
<p> 让我们来继续做更多的扩展，Student和Employee实现另一个方法Sing，然后Student实现方法BorrowMoney而Employee实现SpendSalary。</p>
<p> 这样Student实现了三个方法：SayHi、Sing、BorrowMoney；而Employee实现了SayHi、Sing、SpendSalary。</p>
<p> 上面这些方法的组合称为interface(被对象Student和Employee实现)。例如Student和Employee都实现了interface：SayHi和Sing，也就是这两个对象是该interface类型。而Employee没有实现这个interface：SayHi、Sing和BorrowMoney，因为Employee没有实现BorrowMoney这个方法。</p>
<h3 id="interface-1"><a href="#interface-1" class="headerlink" title="interface"></a>interface</h3><p> interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">type Human struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">	phone string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">	Human //匿名字段Human</span><br><span class="line">	school string</span><br><span class="line">	loan float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">	Human //匿名字段Human</span><br><span class="line">	company string</span><br><span class="line">	money float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Human对象实现Sayhi方法</span><br><span class="line">func (h *Human) SayHi() &#123;</span><br><span class="line">	fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Human对象实现Sing方法</span><br><span class="line">func (h *Human) Sing(lyrics string) &#123;</span><br><span class="line">	fmt.Println(&quot;La la, la la la, la la la la la...&quot;, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Human对象实现Guzzle方法</span><br><span class="line">func (h *Human) Guzzle(beerStein string) &#123;</span><br><span class="line">	fmt.Println(&quot;Guzzle Guzzle Guzzle...&quot;, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Employee重载Human的Sayhi方法</span><br><span class="line">func (e *Employee) SayHi() &#123;</span><br><span class="line">	fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;, e.name,</span><br><span class="line">		e.company, e.phone) //此句可以分成多行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Student实现BorrowMoney方法</span><br><span class="line">func (s *Student) BorrowMoney(amount float32) &#123;</span><br><span class="line">	s.loan += amount // (again and again and...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Employee实现SpendSalary方法</span><br><span class="line">func (e *Employee) SpendSalary(amount float32) &#123;</span><br><span class="line">	e.money -= amount // More vodka please!!! Get me through the day!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义interface</span><br><span class="line">type Men interface &#123;</span><br><span class="line">	SayHi()</span><br><span class="line">	Sing(lyrics string)</span><br><span class="line">	Guzzle(beerStein string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type YoungChap interface &#123;</span><br><span class="line">	SayHi()</span><br><span class="line">	Sing(song string)</span><br><span class="line">	BorrowMoney(amount float32)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ElderlyGent interface &#123;</span><br><span class="line">	SayHi()</span><br><span class="line">	Sing(song string)</span><br><span class="line">	SpendSalary(amount float32)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 通过上面的代码我们可以知道，interface可以被任意的对象实现。我们看到上面的Men interface被Human、Student和Employee实现。同理，一个对象可以实现任意多个interface，例如上面的Student实现了Men和YoungChap两个interface。</p>
<p> 最后，任意的类型都实现了空interface(我们这样定义：interface{})，也就是包含0个method的interface。</p>
<h3 id="interface值"><a href="#interface值" class="headerlink" title="interface值"></a>interface值</h3><p> 那么interface里面到底能存什么值呢？如果我们定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，我们定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值。</p>
<p> 因为m能够持有这三种类型的对象，所以我们可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了Men接口的任意结构的对象，这个和我们传统意义上面的slice有所不同。</p>
<p> 让我们来看一下下面这个例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">	phone string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">	Human //匿名字段</span><br><span class="line">	school string</span><br><span class="line">	loan float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">	Human //匿名字段</span><br><span class="line">	company string</span><br><span class="line">	money float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Human实现SayHi方法</span><br><span class="line">func (h Human) SayHi() &#123;</span><br><span class="line">	fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Human实现Sing方法</span><br><span class="line">func (h Human) Sing(lyrics string) &#123;</span><br><span class="line">	fmt.Println(&quot;La la la la...&quot;, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Employee重载Human的SayHi方法</span><br><span class="line">func (e Employee) SayHi() &#123;</span><br><span class="line">	fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;, e.name,</span><br><span class="line">		e.company, e.phone)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">// Interface Men被Human,Student和Employee实现</span><br><span class="line">// 因为这三个类型都实现了这两个方法</span><br><span class="line">type Men interface &#123;</span><br><span class="line">	SayHi()</span><br><span class="line">	Sing(lyrics string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	mike := Student&#123;Human&#123;&quot;Mike&quot;, 25, &quot;222-222-XXX&quot;&#125;, &quot;MIT&quot;, 0.00&#125;</span><br><span class="line">	paul := Student&#123;Human&#123;&quot;Paul&quot;, 26, &quot;111-222-XXX&quot;&#125;, &quot;Harvard&quot;, 100&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;&quot;Sam&quot;, 36, &quot;444-222-XXX&quot;&#125;, &quot;Golang Inc.&quot;, 1000&#125;</span><br><span class="line">	tom := Employee&#123;Human&#123;&quot;Tom&quot;, 37, &quot;222-444-XXX&quot;&#125;, &quot;Things Ltd.&quot;, 5000&#125;</span><br><span class="line"></span><br><span class="line">	//定义Men类型的变量i</span><br><span class="line">	var i Men</span><br><span class="line"></span><br><span class="line">	//i能存储Student</span><br><span class="line">	i = mike</span><br><span class="line">	fmt.Println(&quot;This is Mike, a Student:&quot;)</span><br><span class="line">	i.SayHi()</span><br><span class="line">	i.Sing(&quot;November rain&quot;)</span><br><span class="line"></span><br><span class="line">	//i也能存储Employee</span><br><span class="line">	i = tom</span><br><span class="line">	fmt.Println(&quot;This is tom, an Employee:&quot;)</span><br><span class="line">	i.SayHi()</span><br><span class="line">	i.Sing(&quot;Born to be wild&quot;)</span><br><span class="line"></span><br><span class="line">	//定义了slice Men</span><br><span class="line">	fmt.Println(&quot;Let&#x27;s use a slice of Men and see what happens&quot;)</span><br><span class="line">	x := make([]Men, 3)</span><br><span class="line">	//这三个都是不同类型的元素，但是他们实现了interface同一个接口</span><br><span class="line">	x[0], x[1], x[2] = paul, sam, mike</span><br><span class="line"></span><br><span class="line">	for _, value := range x&#123;</span><br><span class="line">		value.SayHi()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 通过上面的代码，你会发现interface就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实现， Go通过interface实现了duck-typing:即”当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。</p>
<h3 id="空interface"><a href="#空interface" class="headerlink" title="空interface"></a>空interface</h3><p> 空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义a为空接口</span><br><span class="line">var a interface&#123;&#125;</span><br><span class="line">var i int = 5</span><br><span class="line">s := &quot;Hello world&quot;</span><br><span class="line">// a可以存储任意类型的数值</span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure><br> 一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值!</p>
<h3 id="interface函数参数"><a href="#interface函数参数" class="headerlink" title="interface函数参数"></a>interface函数参数</h3><p> interface的变量可以持有任意实现该interface类型的对象，这给我们编写函数(包括method)提供了一些额外的思考，我们是不是可以通过定义interface参数，让函数接受各种类型的参数。</p>
<p> 举个例子：fmt.Println是我们常用的一个函数，但是你是否注意到它可以接受任意类型的数据。打开fmt的源码文件，你会看到这样一个定义:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">	 String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 也就是说，任何实现了String方法的类型都能作为参数被fmt.Println调用:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">	phone string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过这个方法 Human 实现了 fmt.Stringer</span><br><span class="line">func (h Human) String() string &#123;</span><br><span class="line">	return &quot;❰&quot;+h.name+&quot; - &quot;+strconv.Itoa(h.age)+&quot; years -  ✆ &quot; +h.phone+&quot;❱&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	Bob := Human&#123;&quot;Bob&quot;, 39, &quot;000-7777-XXX&quot;&#125;</span><br><span class="line">	fmt.Println(&quot;This Human is : &quot;, Bob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 现在我们再回顾一下前面的Box示例，你会发现Color结构也定义了一个method：String。其实这也是实现了fmt.Stringer这个interface，即如果需要某个类型能被fmt包以特殊的格式输出，你就必须实现Stringer这个接口。如果没有实现这个接口，fmt将以默认的方式输出。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//实现同样的功能</span><br><span class="line">fmt.Println(&quot;The biggest one is&quot;, boxes.BiggestsColor().String())</span><br><span class="line">fmt.Println(&quot;The biggest one is&quot;, boxes.BiggestsColor())</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：实现了error接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。</p>
</blockquote>
<h1 id="终结（Java-ing…）"><a href="#终结（Java-ing…）" class="headerlink" title="终结（Java ing…）"></a>终结（Java ing…）</h1><h1 id="学习参考资料"><a href="#学习参考资料" class="headerlink" title="学习参考资料"></a>学习参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://tour.studygolang.com/flowcontrol/1">Go指南</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rxov</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rxvo.github.io/post/go.html">https://rxvo.github.io/post/go.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rxvo.github.io" target="_blank">Live Your Life</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638856406&amp;t=f2a64ef1b887e37b9d00add7521ea926" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/imgg/wechat.JPG" target="_blank"><img class="post-qr-code-img" src="/imgg/wechat.JPG" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/imgg/alipay.JPG" target="_blank"><img class="post-qr-code-img" src="/imgg/alipay.JPG" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/java.html"><img class="prev-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638856406&amp;t=f2a64ef1b887e37b9d00add7521ea926" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaEE's Learning</div></div></a></div><div class="next-post pull-right"><a href="/post/post1.html"><img class="next-cover" src="https://pic2.zhimg.com/v2-bf39215f40fc816eb497816eedfbe345_1440w.jpg?source=172ae18b" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Learning to Group and Label Fine-Grained Shape Components</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://z3.ax1x.com/2021/05/14/gymhKH.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Rxov</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RXvo" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1286623452@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.coolapk.com/apk/com.qjhcqaq.icons" target="_blank" title="Coolapk"><i class="fab fa-uncharted"></i></a><a class="social-icon" href="https://www.zhihu.com/people/bai-yin-3" target="_blank" title="知乎"><i class="fab fa-zhihu"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">河流从不催促过河的人。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">安装配置相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">关键点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">Go语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%94%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.</span> <span class="toc-text">二十五个关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">定义变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.4.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">内置基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean"><span class="toc-number">2.5.1.</span> <span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">数值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.3.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E6%95%B0%E6%8D%AE%E5%BA%95%E5%B1%82%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">2.5.4.</span> <span class="toc-text">Go数据底层的存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7"><span class="toc-number">2.6.</span> <span class="toc-text">一些技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.6.1.</span> <span class="toc-text">分组声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iota%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.6.2.</span> <span class="toc-text">iota枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%99"><span class="toc-number">2.6.3.</span> <span class="toc-text">Go程序设计的一些规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array%E3%80%81slice%E3%80%81map"><span class="toc-number">2.6.4.</span> <span class="toc-text">array、slice、map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#array"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slice"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">slice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-number">2.6.4.3.</span> <span class="toc-text">map</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make%E3%80%81new%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.5.</span> <span class="toc-text">make、new操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E5%80%BC"><span class="toc-number">2.7.</span> <span class="toc-text">零值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">流程和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-number">3.1.1.</span> <span class="toc-text">if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goto"><span class="toc-number">3.1.2.</span> <span class="toc-text">goto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-number">3.1.3.</span> <span class="toc-text">for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">3.1.4.</span> <span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.2.1.</span> <span class="toc-text">多个返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E5%8F%82"><span class="toc-number">3.2.2.</span> <span class="toc-text">变参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC%E4%B8%8E%E4%BC%A0%E6%8C%87%E9%92%88"><span class="toc-number">3.2.3.</span> <span class="toc-text">传值与传指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-number">3.2.4.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%80%BC%E3%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.5.</span> <span class="toc-text">函数作为值、类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Panic%E5%92%8CRecover"><span class="toc-number">3.2.6.</span> <span class="toc-text">Panic和Recover</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0%E5%92%8Cinit%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.7.</span> <span class="toc-text">main函数和init函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import"><span class="toc-number">3.2.8.</span> <span class="toc-text">import</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#struct%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">struct类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct"><span class="toc-number">4.1.</span> <span class="toc-text">struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">struct的匿名字段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#method"><span class="toc-number">5.1.</span> <span class="toc-text">method</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BAreceiver"><span class="toc-number">5.1.1.</span> <span class="toc-text">指针作为receiver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#method%E7%BB%A7%E6%89%BF"><span class="toc-number">5.1.2.</span> <span class="toc-text">method继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#method%E9%87%8D%E5%86%99"><span class="toc-number">5.1.3.</span> <span class="toc-text">method重写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Interface"><span class="toc-number">6.</span> <span class="toc-text">Interface</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#interface"><span class="toc-number">6.1.</span> <span class="toc-text">interface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFinterface"><span class="toc-number">6.1.1.</span> <span class="toc-text">什么是interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface-1"><span class="toc-number">6.1.2.</span> <span class="toc-text">interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface%E5%80%BC"><span class="toc-number">6.1.3.</span> <span class="toc-text">interface值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BAinterface"><span class="toc-number">6.1.4.</span> <span class="toc-text">空interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">6.1.5.</span> <span class="toc-text">interface函数参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%EF%BC%88Java-ing%E2%80%A6%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">终结（Java ing…）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">8.</span> <span class="toc-text">学习参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/error.html" title="Error"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638856406&amp;t=f2a64ef1b887e37b9d00add7521ea926" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Error"/></a><div class="content"><a class="title" href="/post/error.html" title="Error">Error</a><time datetime="2021-12-27T12:47:37.000Z" title="发表于 2021-12-27 20:47:37">2021-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/java.html" title="JavaEE's Learning"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638856406&amp;t=f2a64ef1b887e37b9d00add7521ea926" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaEE's Learning"/></a><div class="content"><a class="title" href="/post/java.html" title="JavaEE's Learning">JavaEE's Learning</a><time datetime="2021-12-01T01:40:37.000Z" title="发表于 2021-12-01 09:40:37">2021-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/go.html" title="Go's Learning"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fcadec2aeca0d9e69ace12557370d6ed74c7c9414.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638856406&amp;t=f2a64ef1b887e37b9d00add7521ea926" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go's Learning"/></a><div class="content"><a class="title" href="/post/go.html" title="Go's Learning">Go's Learning</a><time datetime="2021-11-07T05:40:37.000Z" title="发表于 2021-11-07 13:40:37">2021-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/post1.html" title="Learning to Group and Label Fine-Grained Shape Components"><img src="https://pic2.zhimg.com/v2-bf39215f40fc816eb497816eedfbe345_1440w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Learning to Group and Label Fine-Grained Shape Components"/></a><div class="content"><a class="title" href="/post/post1.html" title="Learning to Group and Label Fine-Grained Shape Components">Learning to Group and Label Fine-Grained Shape Components</a><time datetime="2021-11-05T13:18:45.000Z" title="发表于 2021-11-05 21:18:45">2021-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/position.html" title="姿态角与四元数"><img src="https://z3.ax1x.com/2021/11/05/Iut68x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="姿态角与四元数"/></a><div class="content"><a class="title" href="/post/position.html" title="姿态角与四元数">姿态角与四元数</a><time datetime="2021-11-05T12:59:45.000Z" title="发表于 2021-11-05 20:59:45">2021-11-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Rxov</div><div class="footer_custom_text">Hi, welcome to my <a href="www.baidu.com">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'DqMfrFMV57n1pOhaVzDoGfwx-MdYXbMMI',
      appKey: '86wdpP7iC3kdGTRlTEoC8mvR',
      placeholder: '记得留下你的昵称和邮箱....可以快速收到回复',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>(function(d, w, c) {
    w.ChatraID = '6dEMJKyRkc64Swf7G';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>