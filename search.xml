<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Flea算法相关</title>
      <link href="/post/flea.html"/>
      <url>/post/flea.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h1><p>奇异值分解(Singular Value Decomposition，以下简称SVD)是在机器学习领域广泛应用的算法，它不光可以用于降维算法中的特征分解，还可以用于推荐系统，以及自然语言处理等领域。</p><h2 id="回顾特征值和特征向量"><a href="#回顾特征值和特征向量" class="headerlink" title="回顾特征值和特征向量"></a>回顾特征值和特征向量</h2><p>首先回顾下特征值和特征向量的定义如下：</p><script type="math/tex; mode=display">A x=\lambda x</script><p>其中<script type="math/tex">A</script>是一个<script type="math/tex">n×n</script>矩阵，<script type="math/tex">x</script>是一个<script type="math/tex">n</script>维向量，则<script type="math/tex">\lambda</script>是矩阵<script type="math/tex">A</script>的一个特征值，而<script type="math/tex">x</script>是矩阵<script type="math/tex">A</script>的特征值<script type="math/tex">\lambda</script>所对应的特征向量。</p><p>求出特征值和特征向量有什么好处呢？就是我们可以将矩阵<script type="math/tex">A</script>特征分解。如果我们求出了矩阵A的n个特征值<script type="math/tex">\lambda_{1} \leq \lambda_{2} \leq \ldots \leq \lambda_{n}</script> ，以及这n个特征值所对应的特征向量<script type="math/tex">w_{1}, w_{2}, \ldots, w_{n}</script>，那么矩阵A就可以用下式的特征分解表示：</p><script type="math/tex; mode=display">A=W \Sigma W^{-1}</script><p>其中W是这n个特征向量所张成的n×n维矩阵，而<script type="math/tex">Σ</script>为这n个特征值为主对角线的<script type="math/tex">n×n</script>维矩阵。</p><p>一般我们会把W的这n个特征向量标准化，即满足<script type="math/tex">\left\|w_{i}\right\|_{2}=1</script>，或者<script type="math/tex">w_{i}^{T} w_{i}=1</script>，此时W的n个特征向量为标准正交基，满足<script type="math/tex">W^{T} W=I</script>，即<script type="math/tex">W^{T}=W^{-1}</script>，也就是说W为酉矩阵。这样我们的特征分解表达式可以写成</p><script type="math/tex; mode=display">A=W \Sigma W^{T}</script><p>注意到要进行特征分解，矩阵A必须为方阵。<br>那么如果A不是方阵，即行和列不相同时，我们还可以对矩阵进行分解吗？答案是可以，此时我们的SVD登场了。</p><h2 id="SVD的定义"><a href="#SVD的定义" class="headerlink" title="SVD的定义"></a>SVD的定义</h2><p>SVD也是对矩阵进行分解，但是和特征分解不同，SVD并不要求要分解的矩阵为方阵。假设我们的矩阵A是一个m×n的矩阵，那么我们定义矩阵A的SVD为：</p><script type="math/tex; mode=display">A=U \Sigma V^{T}</script><p>其中U是一个<script type="math/tex">m×m</script>的矩阵，<script type="math/tex">Σ</script>是一个<script type="math/tex">m×n</script>的矩阵，除了主对角线上的元素以外全为0，主对角线上的每个元素都称为奇异值，V是一个<script type="math/tex">n×n</script>的矩阵。U和V都是酉矩阵，即满足<script type="math/tex">U^{T} U=I, V^{T} V=I</script> 。<br>下图可以很形象的看出上面SVD的定义：<br><img src="https://pic4.zhimg.com/v2-5ee98f8f3426b845bc1c5038ecd29593_r.jpg" alt=""><br>如何求出SVD分解后的U,Σ,V这三个矩阵呢？</p><p>如果我们将A的转置和A做矩阵乘法，那么会得到n×n的一个方阵<script type="math/tex">A^{T} A</script>。既然<script type="math/tex">A^{T} A</script>是方阵，那么我们就可以进行特征分解，得到的特征值和特征向量满足下式：</p><script type="math/tex; mode=display">\left(A^{T} A\right) v_{i}=\lambda_{i} v_{i}</script><p>这样我们就可以得到矩阵<script type="math/tex">A^{T} A</script>的n个特征值和对应的n个特征向量v了。将<script type="math/tex">\sigma_{i}=\frac{A v_{i}}{u_{i}}</script>的所有特征向量张成一个n×n的矩阵V，就是我们SVD公式里面的V矩阵了。一般我们将V中的每个特征向量叫做A的右奇异向量。</p><p>如果我们将A和A的转置做矩阵乘法，那么会得到m×m的一个方阵<script type="math/tex">A A^{T}</script>。既然<script type="math/tex">A A^{T}</script>是方阵，那么我们就可以进行特征分解，得到的特征值和特征向量满足下式：</p><script type="math/tex; mode=display">\left(A A^{T}\right) u_{i}=\lambda_{i} u_{i}</script><p>这样我们就可以得到矩阵<script type="math/tex">A A^{T}</script>的m个特征值和对应的m个特征向量u了。将<script type="math/tex">A A^{T}</script>的所有特征向量张成一个m×m的矩阵U，就是我们SVD公式里面的U矩阵了。一般我们将U中的每个特征向量叫做A的左奇异向量。</p><p>U和V我们都求出来了，现在就剩下奇异值矩阵Σ没有求出了. 由于Σ除了对角线上是奇异值其他位置都是0，那我们只需要求出每个奇异值σ就可以了。</p><p>我们注意到:</p><script type="math/tex; mode=display">A=U \Sigma V^{T} \Rightarrow A V=U \Sigma V^{T} V \Rightarrow A V=U \Sigma \Rightarrow A v_{i}=\sigma_{i} u_{i} \Rightarrow \sigma_{i}=A v_{i} / u_{i}</script><p>这样我们可以求出我们的每个奇异值，进而求出奇异值矩阵Σ。</p><p>上面还有一个问题没有讲，就是我们说<script type="math/tex">A^{T} A</script>的特征向量组成的就是我们SVD中的V矩阵，而<script type="math/tex">A A^{T}</script>的特征向量组成的就是我们SVD中的U矩阵，这有什么根据吗？这个其实很容易证明，我们以V矩阵的证明为例。</p><p>进一步我们还可以看出我们的特征值矩阵等于奇异值矩阵的平方，也就是说特征值和奇异值满足如下关系：</p><script type="math/tex; mode=display">\sigma_{i}=\sqrt{\lambda_{i}}</script><p>这样也就是说，我们可以不用<script type="math/tex">\sigma_{i}=\frac{A v_{i}}{u_{i}}</script>来计算奇异值，也可以通过求出<script type="math/tex">A^{T} A</script>的特征值取平方根来求奇异值。</p><h1 id="论文结构"><a href="#论文结构" class="headerlink" title="论文结构"></a>论文结构</h1><p><em>wahba(瓦哈巴问题)</em></p><p>目的：</p><div class="mermaid">flowchart LR多传感器矢量观测--&gt;找到最佳姿态矩阵[也称为方向余弦矩阵（DCM）]</div>]]></content>
      
      
      <categories>
          
          <category> 惯性传感器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位移姿态解算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Error</title>
      <link href="/post/error.html"/>
      <url>/post/error.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="陀螺仪标定"><a href="#陀螺仪标定" class="headerlink" title="陀螺仪标定"></a>陀螺仪标定</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>传统磁罗盘主要由三轴加速度计和三轴磁力计构成(也称为六轴磁罗盘)，三轴加速度计主要用于测量地球重力加速度，根据所测得的数据，求解载体的俯仰角和横滚角，利用求出的俯仰角和横滚角，同时结合三轴磁力计测得的地磁场数据，求解出载体的磁方位角。</p><p>当载体处于准静态（静止或匀速运动)时，三轴加速度计可准确测量地球重力加速度，从而准确求解出载体姿态角。当载体处于动态时，三轴加速度计除了测量地球重力加速度外，还会测得载体自身所产生的加速度，导致姿态角计算不准。因此，六轴磁罗盘只能准确测量准静态下载体的姿态角，而无法用于动态条件时载体姿态角的准确测量。但在实际应用中，大多数载体都是处于动态，由于载体运动对陀螺仪的影响较小，利用这一特性可以解决动态条件下载体姿态角精确测量问题。</p><p>MEMS陀螺仪对姿态误差产生直接影响，其主要表现是MEMS陀螺仪固定常值漂移、陀螺仪的安装误差对捷联惯导系统的姿态误差的影响。</p><h2 id="零偏"><a href="#零偏" class="headerlink" title="零偏"></a>零偏</h2><p>零偏，又称为零位漂移或零位偏移或零偏稳定性，也可简称零漂或漂移率，英文中称为drift 或bias drift。零偏应理解为陀螺仪的输出信号围绕其均值的起伏或波动，习惯上用标准差（σ）或均方根（RMS ）表示，一般折算为等效输入角速率(°/ h) 。在角速度输入为零时，陀螺仪的输出是一条复合白噪声信号缓慢变化的曲线，曲线的峰-峰值就是零偏值（drift ），如图2-6所示。在整个性能指标集中，零偏是评价陀螺仪性能优劣的最重要指标。</p><p>其次想说明下陀螺仪零偏的指标，这其中包括了零偏稳定性，零偏重复性，噪声强度，随机游走，零偏不稳定性等</p><p>从原理上来讲，陀螺仪上电或开始工作时会出现漂移，又分为常值漂移和随机漂移两种，其中常值漂移就叫零偏。通过获取陀螺仪的零偏，我们就可以在后续系统使用中对其进行补偿，但补偿的是多次测量的均值，在补偿后常值漂移在陀螺的输出中还会有一部分残余，因此，就出现了陀螺测试大纲中的零偏重复性指标，它表征陀螺每次零偏的接近重复程度，零偏重复性好的陀螺经过标定补偿后，残余的常值漂移比较小，可以达到更高的精度。</p><p>零偏稳定性则是计算一次通电过程中陀螺输出数据的方差得到，计算方差时上面提到的常值漂移被扣除，因此零偏稳定性反映的是陀螺的随机漂移指标，又称随机噪声。关于陀螺仪的零偏稳定性，有一点要说明:对于陀螺的零偏稳定性而言，通常采集一段时间的数据，计算这一段数据的均方差，而陀螺的噪声一般认为是白噪声，因此平均(平滑）时间越长，这个指标显得越好。两款陀螺仪，如果A的100s平滑数据与B的1s平滑数据相同，那B的性能一定好于A，这就是为什么很多数据手册上在零偏指标后会有采样时间的说明。</p><h1 id="艾伦方差（Allan）"><a href="#艾伦方差（Allan）" class="headerlink" title="艾伦方差（Allan）"></a>艾伦方差（Allan）</h1><p>Allan方差分析主要用于分析陀螺量化噪声、角度随机游走噪声（角速率白噪声）、零偏不稳定性、角速率随机游走（角加速度白噪声）和速率斜坡（角速率常值趋势项）等五种典型误差。</p><h1 id="RBF神经网络理论与实现"><a href="#RBF神经网络理论与实现" class="headerlink" title="RBF神经网络理论与实现"></a>RBF神经网络理论与实现</h1><h2 id="理论参考"><a href="#理论参考" class="headerlink" title="理论参考"></a>理论参考</h2><p> 径向基函数(Radial Basis Function,RBF)神经网络，其实它就是将RBF作为神经网络层间的一种连接方式而已。这里做一个简单的描述和找了个代码解读。</p><p> 参考博客：</p><ul><li><a href="https://en.wikipedia.org/wiki/Radial_basis_function">维基百科径向基函数</a></li></ul><ul><li>《模式识别与智能计算——matlab技术实现第三版》第6.3章节</li></ul><ul><li>《matlab神经网络43个案例分析》第7章节</li></ul><ul><li><a href="https://github.com/PetraVidnerova/rbf_for_tf2">tensorflow2.0实现RBF</a></li></ul><ul><li>numpy的实现</li></ul><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p> 用RBF作为隐单元的“基”构成隐藏层空间，隐藏层对输入矢量进行变换，将低维的模式输入数据变换到高维空间内，使得在低维空间内的线性不可分问题在高维空间内线性可分。</p><p> 详细一点就是用RBF的隐单元的“基”构成隐藏层空间，这样就可以将输入矢量直接(不通过权连接)映射到隐空间。当RBF的中心点确定以后，这种映射关系也就确定 了。而隐含层空间到输出空间的映射是线性的(注意这个地方区分一下线性映射和非线性映射的关系)，即网络输出是隐单元输出的线性加权和，此处的权即为网络可调参数。</p><p> 径向基神经网络的节点激活函数采用径向基函数，定义了空间中任一点到某一中心点的欧式距离的单调函数。</p><p> 我们通常使用的函数是高斯函数：</p><script type="math/tex; mode=display">\phi(r)=e^{-(\epsilon r)^{2}}</script><p> 在《Phase-Functioned Neural Networks for Character Control》论文代码中有提到很多径向基函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kernels = &#123;</span><br><span class="line">    &#x27;multiquadric&#x27;: lambda x: np.sqrt(x**2 + 1),</span><br><span class="line">    &#x27;inverse&#x27;:      lambda x: 1.0 / np.sqrt(x**2 + 1),</span><br><span class="line">    &#x27;gaussian&#x27;:     lambda x: np.exp(-x**2),</span><br><span class="line">    &#x27;linear&#x27;:       lambda x: x,</span><br><span class="line">    &#x27;quadric&#x27;:      lambda x: x**2,</span><br><span class="line">    &#x27;cubic&#x27;:        lambda x: x**3,</span><br><span class="line">    &#x27;quartic&#x27;:      lambda x: x**4,</span><br><span class="line">    &#x27;quintic&#x27;:      lambda x: x**5,</span><br><span class="line">    &#x27;thin_plate&#x27;:   lambda x: x**2 * np.log(x + 1e-10),</span><br><span class="line">    &#x27;logistic&#x27;:     lambda x: 1.0 / (1.0 + np.exp(-np.clip(x, -5, 5))),</span><br><span class="line">    &#x27;smoothstep&#x27;:   lambda x: ((np.clip(1.0 - x, 0.0, 1.0))**2.0) * (3 - 2*(np.clip(1.0 - x, 0.0, 1.0)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下图是径向基神经元模型:</p><p><img src="https://img-blog.csdnimg.cn/20201102184444803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3piMTE2NTA0ODAxNw==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>径向基函数的激活函数是以输入向量和权值向量（注意此处的权值向量并非隐藏层到输出层的权值，具体看下面的径向基神经元模型结构）之间的距离||dist||作为自变量的，图中的b为阈值，用于调整神经元的灵敏度。径向基网络的激活函数的一般表达式为:</p><script type="math/tex; mode=display">R(\| \text { dist } \|)=e^{-\| \text {dist } \|}</script><p>下图是以高斯核为径向基函数的神经元模型：</p><p><img src="https://img-blog.csdnimg.cn/20201102184458452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3piMTE2NTA0ODAxNw==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>对应到激活函数表达式:</p><script type="math/tex; mode=display">R\left(x_{p}-c_{i}\right)=\exp \left(-\frac{1}{2 \sigma^{2}}\left\|x_{p}-c_{i}\right\|^{2}\right)</script><p>其中X代表输入向量，C代表权值，为高斯函数的中心，σ \sigmaσ是高斯函数的方差，可以用来调整影响半径(仔细想想高斯函数中c cc和σ \sigmaσ调整后对函数图的影响)；当权值和输入向量的距离越小，网络的输出不断递增，输入向量越靠近径向基函数的中心，隐层节点产生的输出越大。也就是说径向基函数对输入信号在局部产生响应，输入向量与权值距离越远，隐层输出越接近0，再经过一层线性变换映射到最终输出层，导致输出层也接近0。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>RBF是具有单隐层的三层前向网络：</p><p><img src="https://img-blog.csdnimg.cn/20201102184509886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3piMTE2NTA0ODAxNw==,size_16,color_FFFFFF,t_70#pic_center" alt="径向基神经网络结构"></p><ul><li>第一层为输入层，由信号源节点组成。</li><li>第二层为隐藏层，隐藏层节点数视所描述问题的需要而定，隐藏层中神经元的变换函数即径向基函数是对中心点径向对称且衰减的非负线性函数，该函数是局部响应函数，具体的局部响应体现在其可见层到隐藏层的变换是通过径向基函数计算，跟其它的网络不同。以前的前向网络变换函数都是全局响应的函数。</li><li>第三层为输出层，是对输入模式做出的响应。</li></ul><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>径向基函数需要两组参数：</p><ul><li>基函数中心</li><li>方差(宽度)</li></ul><p>隐层到输出层只需要一组参数：</p><ul><li>权值  </li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>逼近能力，分类能力和学习速度等方面都优于BP神经网络</li><li>结构简单、训练简洁、学习收敛速度快、能够逼近任意非线性函数</li><li>克服局部极小值问题。原因在于其参数初始化具有一定的方法，并非随机初始化</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>如果中心点是样本中的数据，就并不能反映出真实样本的状况，那么输入到隐层的映射就是不准确的</li><li>如果使用有监督学习，函数中心是学习到的，但是如果中心点选取不当，就会导致不收敛。</li></ul><h2 id="各层的计算"><a href="#各层的计算" class="headerlink" title="各层的计算"></a>各层的计算</h2><p>首先初始化参数：中心、宽度、权值</p><p>不同隐含层神经元的中心应有不同的取值，并且与中心的对应宽度能够调节，使得不同的输入信息特征能被不同的隐含层神经元最大的反映出来，在实际应用时，一个输入信息总是包含在一定的取值范围内。</p><h3 id="中心"><a href="#中心" class="headerlink" title="中心"></a>中心</h3><ul><li><p>方法1</p><p>《模式识别与智能计算》中介绍了一种方法：将隐含层各神经元的中心分量的初值，按从小到大等间距变化，使较弱的输入信息在较小的中心附近产生较强的响应。间距的大小可由隐藏层神经元的个数来调节。好处是能够通过试凑的方法找到较为合理的隐含层神经元数，并使中心的初始化尽量合理，不同的输入特征更为明显地在不同的中心处反映出来，体现高斯核的特点：</p><script type="math/tex; mode=display"> R\left(x_{p}-c_{i}\right)=\exp \left(-\frac{1}{2 \sigma^{2}}\left\|x_{p}-c_{i}\right\|^{2}\right)c_{j i}=\min i+\frac{\max i-\min i}{2 p}+(j-1) \frac{\max i-\min i}{p}</script><p>其中p为隐层神经元总个数，j为隐层神经元索引，i为输入神经元索引，max ⁡ i \max imaxi是训练集中第i个特征所有输入信息的最小值，$\max i $为训练集中第i个特征所有输入信息的最大值。</p></li><li><p>方法2</p><p>《43案例分析》中介绍的是Kmean使用方法，就是传统的算法，先随机选k个样本作为中心，然后按照欧氏距离对每个样本分组，再重新确定聚类中心，再不断重复上面的步骤，直到最终聚类中心变化在一定范围内。</p></li></ul><h3 id="宽度"><a href="#宽度" class="headerlink" title="宽度"></a>宽度</h3><p>宽度向量影响着神经元对输入信息的作用范围：宽度越小，相应隐含层神经元作用函数的形状越窄，那么处于其他神经元中心附近的信息在该神经元出的响应就越小；就跟高斯函数图像两边的上升下降区域的宽度一样。按照《模式识别与智能计算》，计算有点像标准差的计算(但是此处原文没有带平方，不过我觉得应该带上，详细可以查阅这个YouTube视频，不带平方，万一出现负数是无法求根的)：</p><script type="math/tex; mode=display">d_{j i}=d_{f} \sqrt{\frac{1}{N} \sum_{k=1}^{N}\left(x_{i}^{k}-c_{j i}\right)^{2}}</script><p>当然也可以用《43案例分析》里面说的，利用中心之间的最大距离Cmax去计算，其中h是聚类中心个数：</p><script type="math/tex; mode=display">d=\frac{c_{\max }}{\sqrt{2 h}}</script><h3 id="输入层到隐层的计算"><a href="#输入层到隐层的计算" class="headerlink" title="输入层到隐层的计算"></a>输入层到隐层的计算</h3><p>直接套入到选择的径向基函数中：</p><script type="math/tex; mode=display">z_{j}=\exp \left(-\left\|\frac{X-C_{j}}{D_{j}}\right\|^{2}\right)</script><p>其中Cj就是第j个隐层神经元对应的中心向量，由隐层第j个神经元所连接的输入层所有神经元的中心分量构成，即 <script type="math/tex">C_{j}=\left[C_{j 1}, C_{j 2}, \cdots, C_{j n}\right]C_{j}=\left[C_{j 1}, C_{j 2}, \cdots, C_{j n}\right]</script>；<br>Dj为隐层第j个神经元的宽度向量，与Cj对应，Dj越大，隐层对输入向量的影响范围就越大，而且神经元间的平滑程度就更好。</p><h3 id="隐层到输入层的计算"><a href="#隐层到输入层的计算" class="headerlink" title="隐层到输入层的计算"></a>隐层到输入层的计算</h3><p>就是传统的神经网络里面，把核函数去掉，变成了线性映射关系：</p><script type="math/tex; mode=display">y_{k}=\sum_{j=1}^{p} w_{k j} z_{j}</script><p>其中k是输出层神经元个数</p><h3 id="权重迭代"><a href="#权重迭代" class="headerlink" title="权重迭代"></a>权重迭代</h3><p>直接使用梯度下降法训练，中心、宽度、权重都通过学习来自适应调节更新</p><p>\begin{array}{c}<br>w<em>{k j}(t)=w</em>{k j}(t-1)-\eta \frac{\partial E}{\partial w<em>{k j}(t-1)}+\alpha\left[w</em>{k j}(t-1)-w<em>{k j}(t-2)\right] \<br>c</em>{j i}(t)=c<em>{j i}(t-1)-\eta \frac{\partial E}{\partial c</em>{j i}(t-1)}+\alpha\left[c<em>{j i}(t-1)-c</em>{j i}(t-2)\right] \<br>d<em>{j i}(t)=d</em>{j i}(t-1)-\eta \frac{\partial E}{\partial d<em>{j i}(t-1)}+\alpha\left[d</em>{j i}(t-1)-d_{j i}(t-2)\right]<br>\end{array}</p><p>其中η为学习率，E为损失函数，一般就是均方差。</p><h2 id="训练步骤"><a href="#训练步骤" class="headerlink" title="训练步骤"></a>训练步骤</h2><ul><li>先初始化中心、宽度、最后一层权重</li><li>计算损失，如果在接受范围内，停止训练</li><li>利用梯度更新的方法更新中心、宽度、权重</li><li>返回第二步</li></ul>]]></content>
      
      
      <categories>
          
          <category> 惯性传感器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 误差补偿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE&#39;s Learning</title>
      <link href="/post/java.html"/>
      <url>/post/java.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p> “java后端从web开始学，springboot入门，前端稍微会一点就行，然后学springboot各种注解，各种中间件的使用，mysql，redis，mq，文件存储，这些都是常用的，然后学微服务架构等，或者大数据流计算，docker k8s等，有了这些基础，拿一个offer应该很简单了” —leetcode</p><p> “时间这么充裕。 先学java web 基础打好，后面学的会很轻松。在你学javaweb的过程 html，css，js会顺便一起学 ，之后在学spring，springMvc，mybtis，最后学springboot<br> 简单说路线:javaWeb-&gt;SSM框架(时间充裕顺便学下vue前端框架)-&gt;springboot 学完成功入门<br> 进阶 linux和docker容器-&gt;redis（mongoDb等）-&gt;rabbitMq(kafak等)-&gt;springCloud 最后做几个微服务项目，背背八股文 可以准备春秋招了” —leetcode</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><ul><li><p>测试分类：</p><p> 1.黑盒测试：不需要写代码，给输入值，看程序是否能输出期望的值。</p><p> 2.白盒测试：需要写代码的。关注程序具体的执行流程。</p></li></ul><ul><li><p>Junit使用：属于白盒测试</p><ul><li><p>步骤：<br> 1.定义一个测试类(测试用例)</p><pre><code>建议：    测试类名：被测试的类名Test      CalculatorTest    包名：xxx.xxx.xx.test       cn.itcast.test</code></pre><p> 2.定义测试方法：可以独立运行</p><pre><code>建议：    方法名：test测试的方法名       testAdd()    返回值：void    参数列表：空参</code></pre><p> 3.给方法加上@Test</p><p> 4.导入junit依赖环境</p></li></ul><ul><li><p>判定结果： </p><p>   红色：失败</p><p>   绿色：成功</p><p>   一般我们会使用断言操作来处理结果</p><pre><code>   ` Assert.assertEquals(期望的结果,运算的结果);`</code></pre></li></ul><ul><li><p>补充：</p><p> 1.@Before:修饰的方法会在测试方法执行被自动执行。</p><p> 2.@After:修饰的方法会在测试方法执行之后被自动执行。</p></li></ul></li></ul><h3 id="反射（框架设计的灵魂）"><a href="#反射（框架设计的灵魂）" class="headerlink" title="反射（框架设计的灵魂）"></a>反射（框架设计的灵魂）</h3><p> 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</p><p> 反射：将类的各个组成部分封装为其他对象，这就是反射对象</p><p><img src="https://z3.ax1x.com/2021/12/01/oGyI4P.png" alt="三个阶段"></p><p><strong>好处：</strong></p><p>   1.可以在程序运行过程中，操作这些对象。</p><p>   2.可以解耦，提高程序的可扩展性。</p><p> <strong>获取class对象的方式：</strong></p><p> 1.Class.forName(“全类名”)：将字节码文件加载进内存，返回class对象（多用于配置文件，将类名定义在配置文件中。读取文件，加载类）</p><p> 2.类名.class:通过类名的属性class获取（多用于参数的传递）</p><p> 3.对象.getClass():getClass()方法在Object类中定义着（多用于对象的获取字节码的方式）</p><p><strong>结论：</strong></p><p> 同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</p><p> <strong>Class对象功能：</strong></p><p> 获取功能：</p><p> 1.获取成员变量们：</p><pre><code>Field[] getField():获取所有public修饰的成员变量Field getField(String name): 获取指定名称的public修饰的成员变量</code></pre><p>  <strong>Field:成员变量</strong></p><p>1.设置值</p><p> <code>void set(Object obj,Object value)</code></p><p>2.获取值</p><p> <code>get(Object obj)</code></p><p>3.忽略访问权限修饰符的安全检查</p><p> <code>setAccessible(true):暴力反射</code></p><p> 2.获取构造方法们</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;&gt;[] getConstructors()</span><br><span class="line">Constructor&lt;T&gt; getConstructor(类&lt;&gt;... parameterTypes)</span><br><span class="line">Constructor&lt;T&gt; getDeclareConstructor(类&lt;&gt;... parameterTypes)</span><br><span class="line">Constructor&lt;&gt;[] getDeclaredConstructors()</span><br></pre></td></tr></table></figure><p>  <strong>Constructor:构造方法</strong></p><p>创建对象：</p><p>   T newInstance(Object… initargs)</p><p>   如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</p><p> 3.获取成员方法们</p><p> <strong>Method:方法对象</strong></p><p> 执行方法：<code>Object invoke(Object obj,Object...args)</code></p><p> 获取方法名称：<code>String getName</code></p><p> 4.获取类名</p><p> <strong>案例</strong>：</p><p> 需求：写一个“框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法</p><p> 实现：</p><p> 1.配置文件</p><p> 2.反射</p><p> 步骤：</p><p> 1.将需要创建的对象的全类名和需要执行的方法定义在配置文件中</p><p> 2.在程序中加载读取配置文件</p><p> 3.使用反射技术来加载类文件进内存</p><p> 4.创建对象</p><p> 5.执行方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectTest&#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">     //1.加载配置文件</span><br><span class="line">     //1.1创建Properties对象</span><br><span class="line">     Properties pro = new Properties();</span><br><span class="line">     //1.2加载配置文件，转换为一个集合</span><br><span class="line">     //1.2.1获取class目录下的配置文件</span><br><span class="line">     ClassLoader classloader = ReflectTest.class.getClassLoader();</span><br><span class="line">     InputStream is = classLoader.getResourceAsStream(&quot;pro.properties&quot;);</span><br><span class="line">     pro.load(is);</span><br><span class="line">     </span><br><span class="line">     //2.获取配置文件中定义的数据</span><br><span class="line">     String className = pro.getProperty(&quot;className&quot;);</span><br><span class="line">     String methodName = pro.getProperty(&quot;methodName&quot;);</span><br><span class="line">     </span><br><span class="line">     //3.加载该类进内存</span><br><span class="line">     Class cls = Class.forname(className);</span><br><span class="line">     //4.创建对象</span><br><span class="line">     Object obj = cls.newInstance();</span><br><span class="line">     //5.获取方法对象</span><br><span class="line">     Method method = cls.getMethod(methodName);</span><br><span class="line">     //6.执行方法</span><br><span class="line">     method,.invoke(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p> 概念：说明程序的。给计算机看的<br> 注释：用文字描述程序的。给程序员看的</p><p> 定义:注解(Annotation)，也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p><p> 作用分类︰</p><p>   编写文档:通过代码里标识的注解生成文档【生成文档doc文档】</p><p>   代码分析:通过代码里标识的元数据对代码进行分析【使用反射】 </p><p>   编译检查:通过代码里标识的元数据让编译器能够实现基本的编译检查【override】</p><p> <strong>JDK中预定义的一些注解</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@override:检测被该注解标注的方法是否是继承自父类（接口）的</span><br><span class="line">@Deprecated：将该注解标注的内容，表示已过时</span><br><span class="line">@suppressWarnings：压制警告（一般传递参数all @suppressWarnings(&quot;all&quot;)）</span><br></pre></td></tr></table></figure></p><p><strong>自定义注解</strong></p><p>格式：元注解<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Public @interface 注解名称&#123;</span><br><span class="line">     属性列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</p><p> <code>public interface MyAnno extends java.lang.annotation.Annotation&#123;&#125;</code></p><p>属性：接口中可以定义的成员方法</p><p>要求：</p><p>1.属性的返回值类型有下列取值</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul><p>2.定义了属性，在使用时需要给属性赋值 </p><p> 1.如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值</p><p> 2.如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可</p><p> 3.数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}省略</p><p>元注解：用于描述注解的注解</p><ul><li>@Target:描述注解能够作用的位置</li></ul><p>ElemenType取值：</p><p>  1.TYPE:可以作用于类上  </p><p>  2.METHOD:可以作用于方法上</p><p>  3.FIELD:可以作用于成员变量上</p><ul><li>@Retention:描述注解被保留的阶段</li></ul><ul><li>@Documented:描述注解是否被抽取到api文档中</li></ul><ul><li>@Inherited:描述注解是否被子类继承</li></ul><p>小结：</p><p>1.以后大多数时候，我们会使用注解，而不是自定义注解</p><p>2.注解给谁用：1.编译器；2.给解析程序用；</p><p>3.注解不是程序的一部分  </p><h2 id="JavaWeb课程介绍"><a href="#JavaWeb课程介绍" class="headerlink" title="JavaWeb课程介绍"></a>JavaWeb课程介绍</h2><p>1.什么是JavaWeb?</p><p>  使用Java语言开发互联网项目。简单理解：使用Java语言开发网站</p><p>2.课程介绍：30天</p><p>  1.数据库：5天</p><p>  2.网页前端：5天</p><p>  3.Web核心技术;15天</p><p>  4.旅游管理系统：5天</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性</p><p>分类：</p><p>1.主键约束：primary key </p><p>2.非空约束：not null</p><p>3.唯一约束：unique</p><p>4.外键约束：foreign key</p><p><strong>非空约束</strong>:not null</p><p>1．创建表时添加约束<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">       id INT,</span><br><span class="line">       NAME VARCHAR(20)NOT NULL -- name为非空);</span><br><span class="line">);       </span><br></pre></td></tr></table></figure><br>2.创建表完后，添加非空约束<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY NAME VARCHAR(20)NOT NULL;</span><br></pre></td></tr></table></figure><br>3.删除name的非空约束<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY NAME VARCHAR(20);</span><br></pre></td></tr></table></figure></p><p><strong>唯一约束</strong>: unique，某一列的值不能重复</p><p>1．注意︰唯一约束可以有NULL值，但是只能有一条记录为null2．在创建表时，条件唯一约束</p><p>2.在创建表时，条件唯一约束<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">         id INT,</span><br><span class="line">         phone_number VARCHAR(20) UNIQUE --手机号);</span><br></pre></td></tr></table></figure><br>3.删除唯一约束<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu DROP INDEX phone_number;</span><br></pre></td></tr></table></figure><br>4.在表创建完后，添加唯一约束<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</span><br></pre></td></tr></table></figure></p><p><strong>主键约束</strong>: primary key</p><p>1．注意︰</p><ul><li>含义∶非空且唯一</li><li>一张表只能有一个字段为主键</li><li>主键就是表中记录的唯一标识</li></ul><p>2.在创建表时，添加主键约束<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> create table stu(</span><br><span class="line">        id int primary key ,--给id添加主键约束</span><br><span class="line">        name varchar ( 20)</span><br><span class="line">); </span><br></pre></td></tr></table></figure><br>3．删除主键<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--错误alter table stu modify id int ;</span><br><span class="line">ALTER TABLE stu DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><br>4．创建完表后，添加主键<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY id INT PRIMARY KEY;</span><br></pre></td></tr></table></figure><br>5.自动增长</p><ul><li>概念：如果某一列是数值类型的，使用auto_increment可以来完成值的自动增长</li><li>在创建表时，添加主键约束，并且完成主键自增长<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">          id int primary key auto_increment,--给id添加主键约束</span><br><span class="line">          name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>删除自动增长<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY id INT;</span><br></pre></td></tr></table></figure></li><li>添加自动增长<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;</span><br></pre></td></tr></table></figure></li></ul><p><strong>外键约束</strong>:foreign key,让表与表产生关系，从而保证数据的正确性</p><p>1.在创建表时，可以添加外键</p><p>语法∶<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table表名(</span><br><span class="line">constraint外键名称 foreign key(外键列名称) references主表名称(主表列名称)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>2.删除外键<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE表名DROP FOREIGN KEY外键名称;</span><br></pre></td></tr></table></figure></p><p>3．创建表之后，添加外键<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE表名 ADD CONSTRAINT 外键名称FOREIGN KEY(外键字段名称）REFERENCES 主表名称(主表列名称);</span><br></pre></td></tr></table></figure><br>SQL分类∶</p><p>1.DDL:操作数据库和表</p><p>2.DML:增删改表中数据</p><p>3.DQL:查询表中数据</p><p>4.DCL:管理用户，授权</p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>概念：Java DataBase Connectivity   Java数据库连接，Java语言操作数据库</p><p>JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类</p><p>步骤：</p><p>1.导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</p><ul><li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li></ul><ul><li>右键—&gt;Add As Library</li></ul><p>2.注册驱动<br>3.获取数据库连接对象 Connection<br>4.定义sql<br>5.获取执行sql语句的对象 Statement<br>6.执行sql，接收返回结果<br>7.处理结果<br>8.释放资源</p><p>3.详解各个对象：</p><ul><li><p>DriverManager:驱动管理对象</p><p>功能：</p><ol><li>注册驱动：告诉程序该使用哪一个数据库驱动jar</li><li>获取数据库连接：方法：static Connection getConnection(String url, String user, String password)；语法：jdbc:mysql://ip地址(域名):端口号/数据库名称</li></ol></li><li><p>Connection:数据库连接对象</p><p>功能：</p><ol><li>获取执行sql 的对象</li><li>管理事务：<ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li><li>提交事务：commit()</li><li>回滚事务：rollback()</li></ul></li><li>Statement：执行sql的对象</li></ol></li><li><p>Statement:执行sql的对象</p><p>执行sql</p><ul><li>boolean execute(String sql) ：可以执行任意的sql 了解</li><li>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句</li></ul><ul><li>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</li></ul><ul><li>ResultSet executeQuery(String sql) ：执行DQL（select)语句</li></ul></li><li><p>ResultSet：结果集对象,封装查询结果</p><ul><li>练习：<ul><li>定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。</li></ul><ol><li>定义Emp类</li><li>定义方法 public List<Emp> findAll(){}</li><li>实现方法 select * from emp;</li></ol></li></ul></li><li><p>PreparedStatement：执行sql的对象</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go&#39;s Learning</title>
      <link href="/post/go.html"/>
      <url>/post/go.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="安装配置相关"><a href="#安装配置相关" class="headerlink" title="安装配置相关"></a>安装配置相关</h1><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><p> 配置Go mod镜像（使用VSCode）解决导包FAILED的问题</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.4.md">主要参考1</a></li></ul><ul><li><a href="https://blog.csdn.net/qq_45914985/article/details/109555913?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=vs%E9%85%8D%E7%BD%AEgo&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-109555913.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187">主要参考2</a></li></ul><h1 id="Go语言基础"><a href="#Go语言基础" class="headerlink" title="Go语言基础"></a>Go语言基础</h1><h2 id="二十五个关键字"><a href="#二十五个关键字" class="headerlink" title="二十五个关键字"></a>二十五个关键字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break    default      func    interface    select</span><br><span class="line">case     defer        go      map          struct</span><br><span class="line">chan     else         goto    package      switch</span><br><span class="line">const    fallthrough  if      range        type</span><br><span class="line">continue for          import  return       var</span><br></pre></td></tr></table></figure><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p> Go使用package（和Python的模块类似）来组织代码。main.main()函数(这个函数位于主包）是每一个独立的可运行程序的入口点。Go使用UTF-8字符串和标识符(因为UTF-8的发明者也就是Go的发明者之一)，所以它天生支持多语言。</p><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p> 使用var关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面：<br> 单变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量</span><br><span class="line">var variableName type</span><br></pre></td></tr></table></figure><br> 多变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//定义三个类型都是“type”的变量</span><br><span class="line">var vname1, vname2, vname3 type</span><br></pre></td></tr></table></figure><br> 定义变量并初始化值:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//初始化“variableName”的变量为“value”值，类型是“type”</span><br><span class="line">var variableName type = value</span><br></pre></td></tr></table></figure><br> 同时初始化多个变量:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">定义三个变量，它们分别初始化为相应的值</span><br><span class="line">vname1为v1，vname2为v2，vname3为v3</span><br><span class="line">然后Go会根据其相应值的类型来帮你初始化它们</span><br><span class="line">*/</span><br><span class="line">var vname1, vname2, vname3 = v1, v2, v3</span><br></pre></td></tr></table></figure><br> 简化方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">定义三个变量，它们分别初始化为相应的值</span><br><span class="line">vname1为v1，vname2为v2，vname3为v3</span><br><span class="line">编译器会根据初始化的值自动推导出相应的类型</span><br><span class="line">*/</span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure><br> :=这个符号直接取代了var和type,这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用var方式来定义全局变量。</p><p> Go对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了i但未使用;<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var i int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p> 在Go程序中，常量可定义为数值、布尔值或字符串等类型。<br> 用法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const constantName = value</span><br><span class="line">//如果需要，也可以明确指定常量的类型：</span><br><span class="line">const Pi float32 = 3.1415926</span><br></pre></td></tr></table></figure><br> Go常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)， 若指定給float32自动缩短为32bit，指定给float64自动缩短为64bit，详情参考<a href="http://golang.org/ref/spec#Constants">链接</a></p><h2 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p> 在Go中，布尔值的类型为bool，值是true或false，默认为false。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//示例代码</span><br><span class="line">var isActive bool  // 全局变量声明</span><br><span class="line">var enabled, disabled = true, false  // 忽略类型的声明</span><br><span class="line">func test() &#123;</span><br><span class="line">var available bool  // 一般声明</span><br><span class="line">valid := false      // 简短声明</span><br><span class="line">available = true    // 赋值操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p> Go里面也有直接定义好位数的类型：rune, int8, int16, int32, int64和byte, uint8, uint16, uint32, uint64。<br> 浮点数的类型有float32和float64两种（没有float类型），默认是float64。此外还支持复数。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p> Go中的字符串都是采用UTF-8字符集编码。字符串是用一对双引号（””）或反引号（<code> </code>）括起来定义，它的类型是string。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//示例代码</span><br><span class="line">var frenchHello string  // 声明变量为字符串的一般方法</span><br><span class="line">var emptyString string = &quot;&quot;  // 声明了一个字符串变量，初始化为空字符串</span><br><span class="line">func test() &#123;</span><br><span class="line">no, yes, maybe := &quot;no&quot;, &quot;yes&quot;, &quot;maybe&quot;  // 简短声明，同时声明多个变量</span><br><span class="line">japaneseHello := &quot;Konichiwa&quot;  // 同上</span><br><span class="line">frenchHello = &quot;Bonjour&quot;  // 常规赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s string = &quot;hello&quot;</span><br><span class="line">s[0] = &#x27;c&#x27;</span><br></pre></td></tr></table></figure><br> 想要修改可以使用下面代码实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;hello&quot;</span><br><span class="line">c := []byte(s)  // 将字符串 s 转换为 []byte 类型</span><br><span class="line">c[0] = &#x27;c&#x27;</span><br><span class="line">s2 := string(c)  // 再转换回 string 类型</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, s2)</span><br></pre></td></tr></table></figure><br> Go中可以使用+操作符来连接两个字符串：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;hello,&quot;</span><br><span class="line">m := &quot; world&quot;</span><br><span class="line">a := s + m</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, a)</span><br></pre></td></tr></table></figure><br> 修改字符串也可写为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;hello&quot;</span><br><span class="line">s = &quot;c&quot; + s[1:] // 字符串虽不能更改，但可进行切片操作</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, s)</span><br></pre></td></tr></table></figure></p><h3 id="Go数据底层的存储"><a href="#Go数据底层的存储" class="headerlink" title="Go数据底层的存储"></a>Go数据底层的存储</h3><p> 介绍 <a href="http://research.swtch.com/godata">Go数据结构</a> 的文章</p><p> <img src="https://z3.ax1x.com/2021/11/09/IJXrfs.png" alt="Go数据格式的存储"></p><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a>分组声明</h3><p> 在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明。如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;os&quot;</span><br><span class="line"></span><br><span class="line">const i = 100</span><br><span class="line">const pi = 3.1415</span><br><span class="line">const prefix = &quot;Go_&quot;</span><br><span class="line"></span><br><span class="line">var i int</span><br><span class="line">var pi float32</span><br><span class="line">var prefix string</span><br></pre></td></tr></table></figure><br> 可分组写成如下形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const(</span><br><span class="line">i = 100</span><br><span class="line">pi = 3.1415</span><br><span class="line">prefix = &quot;Go_&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var(</span><br><span class="line">i int</span><br><span class="line">pi float32</span><br><span class="line">prefix string</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="iota枚举"><a href="#iota枚举" class="headerlink" title="iota枚举"></a>iota枚举</h3><p> Go里面有一个关键字iota，这个关键字用来声明enum的时候采用，它默认开始值是0，const中每增加一行加1：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">x = iota // x == 0</span><br><span class="line">y = iota // y == 1</span><br><span class="line">z = iota // z == 2</span><br><span class="line">w        // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">h, i, j = iota, iota, iota //h=0,i=0,j=0 iota在同一行值相同</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">a       = iota //a=0</span><br><span class="line">b       = &quot;B&quot;</span><br><span class="line">c       = iota             //c=2</span><br><span class="line">d, e, f = iota, iota, iota //d=3,e=3,f=3</span><br><span class="line">g       = iota             //g = 4</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>除非被显式设置为其它值或iota，每个const分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是iota，则它也被设置为iota。</p></blockquote><h3 id="Go程序设计的一些规则"><a href="#Go程序设计的一些规则" class="headerlink" title="Go程序设计的一些规则"></a>Go程序设计的一些规则</h3><p> Go之所以会那么简洁，是因为它有一些默认的行为：</p><ul><li>大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。</li></ul><ul><li>大写字母开头的函数也是一样，相当于class中的带public关键词的公有函数；小写字母开头的就是有private关键词的私有函数。</li></ul><hr><h3 id="array、slice、map"><a href="#array、slice、map" class="headerlink" title="array、slice、map"></a>array、slice、map</h3><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p> array就是数组，它的定义方式如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr [n]type</span><br></pre></td></tr></table></figure><br> 在[n]type中，n表示数组的长度，type表示存储元素的类型。对数组的操作和其它语言类似，都是通过[]来进行读取或赋值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr [10]int  // 声明了一个int类型的数组</span><br><span class="line">arr[0] = 42      // 数组下标是从0开始的</span><br><span class="line">arr[1] = 13      // 赋值操作</span><br><span class="line">fmt.Printf(&quot;The first element is %d\n&quot;, arr[0])  // 获取数据，返回42</span><br><span class="line">fmt.Printf(&quot;The last element is %d\n&quot;, arr[9]) //返回未赋值的最后一个元素，默认返回0</span><br></pre></td></tr></table></figure><br> 由于长度也是数组类型的一部分，因此[3]int与[4]int是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的slice类型了。<br> 数组可以使用另一种:=来声明<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := [3]int&#123;1, 2, 3&#125; // 声明了一个长度为3的int数组</span><br><span class="line">b := [10]int&#123;1, 2, 3&#125; // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0</span><br><span class="line">c := [...]int&#123;4, 5, 6&#125; // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度</span><br></pre></td></tr></table></figure><br> Go支持嵌套数组，即多维数组。比如下面的代码就声明了一个二维数组：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span><br><span class="line">doubleArray := [2][4]int&#123;[4]int&#123;1, 2, 3, 4&#125;, [4]int&#123;5, 6, 7, 8&#125;&#125;</span><br><span class="line">// 上面的声明可以简化，直接忽略内部的类型</span><br><span class="line">easyArray := [2][4]int&#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;&#125;</span><br></pre></td></tr></table></figure><br> 数组的分配如下所示：<br> <img src="https://z3.ax1x.com/2021/11/09/IJXDYj.png" alt="多维数组的映射关系"></p><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p> 在很多应用场景中，数组并不能满足我们的需求。在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫slice。slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 和声明array一样，只是少了长度</span><br><span class="line">var fslice []int</span><br></pre></td></tr></table></figure><p> 接下来我们可以声明一个slice，并初始化数据，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []byte &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;</span><br></pre></td></tr></table></figure><p> slice可以从一个数组或一个已经存在的slice中再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个含有10个元素元素类型为byte的数组</span><br><span class="line">var ar = [10]byte &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;&#125;</span><br><span class="line"></span><br><span class="line">// 声明两个含有byte的slice</span><br><span class="line">var a, b []byte</span><br><span class="line"></span><br><span class="line">// a指向数组的第3个元素开始，并到第五个元素结束，</span><br><span class="line">a = ar[2:5]</span><br><span class="line">//现在a含有的元素: ar[2]、ar[3]和ar[4]</span><br><span class="line"></span><br><span class="line">// b是数组ar的另一个slice</span><br><span class="line">b = ar[3:5]</span><br><span class="line">// b的元素是：ar[3]和ar[4]</span><br></pre></td></tr></table></figure><blockquote><p>注意slice和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用…自动计算长度，而声明slice时，方括号内没有任何字符。</p></blockquote><p> 它们的数据结构如下所示:<br> <img src="https://z3.ax1x.com/2021/11/09/IJXBkQ.png" alt="slice和array的对应关系图"></p><p><strong>slice还有一些简便的操作：</strong></p><ul><li>slice的默认开始位置是0，ar[:n]等价于ar[0:n]</li></ul><ul><li>slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]</li></ul><ul><li>如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]<br>下面这个例子展示了更多关于slice的操作：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个数组</span><br><span class="line">var array = [10]byte&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;&#125;</span><br><span class="line">// 声明两个slice</span><br><span class="line">var aSlice, bSlice []byte</span><br><span class="line">// 演示一些简便操作</span><br><span class="line">aSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span><br><span class="line">aSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span><br><span class="line">aSlice = array[:]  // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span><br><span class="line">// 从slice中获取slice</span><br><span class="line">aSlice = array[3:7]  // aSlice包含元素: d,e,f,g，len=4，cap=7</span><br><span class="line">bSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span><br><span class="line">bSlice = aSlice[:3]  // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span><br><span class="line">bSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span><br><span class="line">bSlice = aSlice[:]   // bSlice包含所有aSlice的元素: d,e,f,g</span><br></pre></td></tr></table></figure><p> slice是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的aSlice和bSlice，如果修改了aSlice中元素的值，那么bSlice相对应的值也会改变。</p><p> 从概念上面来说slice像一个结构体，这个结构体包含了三个元素：</p><ul><li>一个指针，指向数组中slice指定的开始位置</li></ul><ul><li>长度，即slice的长度</li></ul><ul><li>最大长度，也就是slice开始位置到数组的最后位置的长度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array_a := [10]byte&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;&#125;</span><br><span class="line">Slice_a := Array_a[2:5]</span><br></pre></td></tr></table></figure><p> 上面所示代码真正存储结构如下图所示：<br><img src="https://z3.ax1x.com/2021/11/09/IJXwTg.png" alt="slice对应数组的信息"></p><p><strong>对于slice有几个有用的内置函数：</strong></p><ul><li>len获取slice的长度</li></ul><ul><li>cap获取slice的最大容量</li></ul><ul><li>append向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice</li></ul><ul><li>copy函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数</li></ul><blockquote><p>注：append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩余空间（即 <em>(cap-len) == 0</em> 时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响。</p></blockquote><p> 从Go1.2开始slice支持了三个参数的slice，之前我们一直采用这种方式在slice或者array基础上来获取一个slice</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array [10]int</span><br><span class="line">slice := array[2:4]</span><br></pre></td></tr></table></figure><p> 这个例子里面slice的容量是8，新版本里面可以指定这个容量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice = array[2:4:7]</span><br></pre></td></tr></table></figure><p> 上面这个的容量就是7-2，即5。这样这个产生的新的slice就没办法访问最后的三个元素。 如果slice是这样的形式array[:i:j]，即第一个参数为空，默认值就是0。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p> map也就是Python中字典的概念，它的格式为map[keyType]valueType</p><p> map的读取和设置也类似slice一样，通过key来操作，只是slice的index只能是｀int｀类型，而map多了很多类型，可以是int，可以是string及所有完全定义了==与!=操作的类型。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化</span><br><span class="line">var numbers map[string]int</span><br><span class="line">// 另一种map的声明方式</span><br><span class="line">numbers = make(map[string]int)</span><br><span class="line">numbers[&quot;one&quot;] = 1  //赋值</span><br><span class="line">numbers[&quot;ten&quot;] = 10 //赋值</span><br><span class="line">numbers[&quot;three&quot;] = 3</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;第三个数字是: &quot;, numbers[&quot;three&quot;]) // 读取数据</span><br><span class="line">// 打印出来如:第三个数字是: 3</span><br></pre></td></tr></table></figure><br> 左边列是key，右边列是值</p><p> <strong>使用map过程中需要注意的几点:</strong></p><ul><li>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取</li></ul><ul><li>map的长度是不固定的，也就是和slice一样，也是一种引用类型</li></ul><ul><li>内置的len函数同样适用于map，返回map拥有的key的数量</li></ul><ul><li>map的值可以很方便的修改，通过numbers[“one”]=11可以很容易的把key为one的字典值改为11</li></ul><ul><li><p>map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</p><p>map的初始化可以通过key:val的方式初始化值，同时map内置有判断是否存在key的方式</p><p>通过delete删除map的元素：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化一个字典</span><br><span class="line">rating := map[string]float32&#123;&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 &#125;</span><br><span class="line">// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true</span><br><span class="line">csharpRating, ok := rating[&quot;C#&quot;]</span><br><span class="line">if ok &#123;</span><br><span class="line">fmt.Println(&quot;C# is in the map and its rating is &quot;, csharpRating)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;We have no rating associated with C# in the map&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete(rating, &quot;C&quot;)  // 删除key为C的元素</span><br></pre></td></tr></table></figure><p> map也是一种引用类型，如果两个map同时指向一个底层，那么一个改变，另一个也相应的改变：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := make(map[string]string)</span><br><span class="line">m[&quot;Hello&quot;] = &quot;Bonjour&quot;</span><br><span class="line">m1 := m</span><br><span class="line">m1[&quot;Hello&quot;] = &quot;Salut&quot;  // 现在m[&quot;hello&quot;]的值已经是Salut了</span><br></pre></td></tr></table></figure><h3 id="make、new操作"><a href="#make、new操作" class="headerlink" title="make、new操作"></a>make、new操作</h3><p> make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。</p><p> 内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：</p><blockquote><p>new返回指针。</p></blockquote><p> 内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值。</p><blockquote><p>make返回初始化后的（非零）值。</p></blockquote><p> 下面这个图详细的解释了new和make之间的区别:<br><img src="https://z3.ax1x.com/2021/11/10/IUPIzT.png" alt="make和new对应底层的内存分配"></p><h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p> 关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。此处罗列部分类型的“零值”<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int     0</span><br><span class="line">int8    0</span><br><span class="line">int32   0</span><br><span class="line">int64   0</span><br><span class="line">uint    0x0</span><br><span class="line">rune    0 //rune的实际类型是 int32</span><br><span class="line">byte    0x0 // byte的实际类型是 uint8</span><br><span class="line">float32 0 //长度为 4 byte</span><br><span class="line">float64 0 //长度为 8 byte</span><br><span class="line">bool    false</span><br><span class="line">string  &quot;&quot;</span><br></pre></td></tr></table></figure></p><h1 id="流程和函数"><a href="#流程和函数" class="headerlink" title="流程和函数"></a>流程和函数</h1><p> 介绍Go的流程控制及函数操作</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p> Go里面if条件判断语句中不需要括号，如下代码所示:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if x &gt; 10 &#123;</span><br><span class="line">fmt.Println(&quot;x is greater than 10&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;x is less than 10&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> Go的if还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 计算获取值x,然后根据x返回的大小，判断是否大于10。</span><br><span class="line">if x := computedValue(); x &gt; 10 &#123;</span><br><span class="line">fmt.Println(&quot;x is greater than 10&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;x is less than 10&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个地方如果这样调用就编译出错了，因为x是条件里面的变量</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure><br> 多条件如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if integer == 3 &#123;</span><br><span class="line">fmt.Println(&quot;The integer is equal to 3&quot;)</span><br><span class="line">&#125; else if integer &lt; 3 &#123;</span><br><span class="line">fmt.Println(&quot;The integer is less than 3&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;The integer is greater than 3&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p> goto跳转到必须在当前函数内定义的标签。例如假设这样一个循环：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func myFunc() &#123;</span><br><span class="line">i := 0</span><br><span class="line">Here:   //这行的第一个词，以冒号结束作为标签</span><br><span class="line">println(i)</span><br><span class="line">i++</span><br><span class="line">goto Here   //跳转到Here去</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>标签名是大小写敏感的。</p></blockquote><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p> for是Go里面最强大的一个控制逻辑，它既可以用来循环读取数据，又可以当作while来控制逻辑，还能迭代操作。语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for expression1; expression2; expression3 &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>expression都是表达式；expression1，expression3：变量声明或函数调用返回值之类；expression2：用来条件判断；expression1在循环开始之前调用，expression3在每轮循环结束之时调用。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">sum := 0;</span><br><span class="line">for index:=0; index &lt; 10 ; index++ &#123;</span><br><span class="line">sum += index</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;sum is equal to &quot;, sum)</span><br><span class="line">&#125;</span><br><span class="line">// 输出：sum is equal to 45</span><br></pre></td></tr></table></figure><p> 有些时候需要进行多个赋值操作，由于Go里面没有,操作符，那么可以使用平行赋值i, j = i+1, j-1</p><p> 有些时候如果我们忽略expression1和expression3：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := 1</span><br><span class="line">for ; sum &lt; 1000;  &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 其中;也可以省略，那么就变成如下的代码了，是不是似曾相识？对，这就是while的功能。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := 1</span><br><span class="line">for sum &lt; 1000 &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在循环里面有两个关键操作break和continue ,break操作是跳出当前循环，continue是跳过本次循环。当嵌套过深的时候，break可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for index := 10; index&gt;0; index-- &#123;</span><br><span class="line">if index == 5&#123;</span><br><span class="line">break // 或者continue</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(index)</span><br><span class="line">&#125;</span><br><span class="line">// break打印出来10、9、8、7、6</span><br><span class="line">// continue打印出来10、9、8、7、6、4、3、2、1</span><br></pre></td></tr></table></figure><br> break和continue还可以跟着标号，用来跳到多重循环中的外层循环</p><p> for配合range可以用于读取slice和map的数据：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for k,v:=range map &#123;</span><br><span class="line">fmt.Println(&quot;map&#x27;s key:&quot;,k)</span><br><span class="line">fmt.Println(&quot;map&#x27;s val:&quot;,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用_来丢弃不需要的返回值 例如<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, v := range map&#123;</span><br><span class="line">fmt.Println(&quot;map&#x27;s val:&quot;, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p> 有些时候你需要写很多的if-else来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候switch就能很好的解决这个问题。它的语法如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch sExpr &#123;</span><br><span class="line">case expr1:</span><br><span class="line">some instructions</span><br><span class="line">case expr2:</span><br><span class="line">some other instructions</span><br><span class="line">case expr3:</span><br><span class="line">some other instructions</span><br><span class="line">default:</span><br><span class="line">other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> sExpr和expr1、expr2、expr3的类型必须一致。Go的switch非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果switch没有表达式，它会匹配true。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i := 10</span><br><span class="line">switch i &#123;</span><br><span class="line">case 1:</span><br><span class="line">fmt.Println(&quot;i is equal to 1&quot;)</span><br><span class="line">case 2, 3, 4:</span><br><span class="line">fmt.Println(&quot;i is equal to 2, 3 or 4&quot;)</span><br><span class="line">case 10:</span><br><span class="line">fmt.Println(&quot;i is equal to 10&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;All I know is that i is an integer&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在第5行中，我们把很多值聚合在了一个case里面，同时，Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">integer := 6</span><br><span class="line">switch integer &#123;</span><br><span class="line">case 4:</span><br><span class="line">fmt.Println(&quot;The integer was &lt;= 4&quot;)</span><br><span class="line">fallthrough</span><br><span class="line">case 5:</span><br><span class="line">fmt.Println(&quot;The integer was &lt;= 5&quot;)</span><br><span class="line">fallthrough</span><br><span class="line">case 6:</span><br><span class="line">fmt.Println(&quot;The integer was &lt;= 6&quot;)</span><br><span class="line">fallthrough</span><br><span class="line">case 7:</span><br><span class="line">fmt.Println(&quot;The integer was &lt;= 7&quot;)</span><br><span class="line">fallthrough</span><br><span class="line">case 8:</span><br><span class="line">fmt.Println(&quot;The integer was &lt;= 8&quot;)</span><br><span class="line">fallthrough</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;default case&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 上面的程序将输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The integer was &lt;= 6</span><br><span class="line">The integer was &lt;= 7</span><br><span class="line">The integer was &lt;= 8</span><br><span class="line">default case</span><br></pre></td></tr></table></figure></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p> 函数是Go里面的核心设计，它通过关键字func来声明，它的格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) &#123;</span><br><span class="line">//这里是处理逻辑代码</span><br><span class="line">//返回多个值</span><br><span class="line">return value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 上面的代码我们看出:</p><ul><li>关键字func用来声明一个函数funcName</li></ul><ul><li>函数可以有一个或者多个参数，每个参数后面带有类型，通过,分隔</li></ul><ul><li>函数可以返回多个值</li></ul><ul><li>上面返回值声明了两个变量output1和output2，如果你不想声明也可以，直接就两个类型</li></ul><ul><li>如果只有一个返回值且不声明返回值变量，那么你可以省略 包括返回值 的括号</li></ul><ul><li>如果没有返回值，那么就直接省略最后的返回信息</li></ul><ul><li><p>如果有返回值， 那么必须在函数的外层添加return语句<br>下面我们来看一个实际应用函数的例子（用来计算Max值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 返回a、b中最大值.</span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">if a &gt; b &#123;</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">x := 3</span><br><span class="line">y := 4</span><br><span class="line">z := 5</span><br><span class="line"></span><br><span class="line">max_xy := max(x, y) //调用函数max(x, y)</span><br><span class="line">max_xz := max(x, z) //调用函数max(x, z)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;max(%d, %d) = %d\n&quot;, x, y, max_xy)</span><br><span class="line">fmt.Printf(&quot;max(%d, %d) = %d\n&quot;, x, z, max_xz)</span><br><span class="line">fmt.Printf(&quot;max(%d, %d) = %d\n&quot;, y, z, max(y,z)) // 也可在这直接调用它</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到max函数有两个参数，它们的类型都是int，那么第一个变量的类型可以省略（即 a,b int,而非 a int, b int)，默认为离它最近的类型，同理多于2个同类型的变量或者返回值。同时我们注意到它的返回值就是一个类型，这个就是省略写法。</p><h3 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h3><p>Go语言比C更先进的特性，其中一点就是函数能够返回多个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//返回 A+B 和 A*B</span><br><span class="line">func SumAndProduct(A, B int) (int, int) &#123;</span><br><span class="line">return A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">x := 3</span><br><span class="line">y := 4</span><br><span class="line"></span><br><span class="line">xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%d + %d = %d\n&quot;, x, y, xPLUSy)</span><br><span class="line">fmt.Printf(&quot;%d * %d = %d\n&quot;, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子我们可以看到直接返回了两个参数，当然我们也可以命名返回参数的变量，这个例子里面只是用了两个类型，我们也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果你的函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func SumAndProduct(A, B int) (add int, Multiplied int) &#123;</span><br><span class="line">add = A+B</span><br><span class="line">Multiplied = A*B</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h3><p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func myfunc(arg ...int) &#123;&#125;</span><br></pre></td></tr></table></figure><p>arg …int告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是int。在函数体中，变量arg是一个int的slice：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, n := range arg &#123;</span><br><span class="line">fmt.Printf(&quot;And the number is: %d\n&quot;, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传值与传指针"><a href="#传值与传指针" class="headerlink" title="传值与传指针"></a>传值与传指针</h3><p>当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。为了验证我们上面的说法，我们来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//简单的一个函数，实现了参数+1的操作</span><br><span class="line">func add1(a int) int &#123;</span><br><span class="line">a = a+1 // 我们改变了a的值</span><br><span class="line">return a //返回一个新值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">x := 3</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;x = &quot;, x)  // 应该输出 &quot;x = 3&quot;</span><br><span class="line"></span><br><span class="line">x1 := add1(x)  //调用add1(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;x+1 = &quot;, x1) // 应该输出&quot;x+1 = 4&quot;</span><br><span class="line">fmt.Println(&quot;x = &quot;, x)    // 应该输出&quot;x = 3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们调用了add1函数，并且在add1中执行a = a+1操作，但是上面例子中x变量的值没有发生变化，理由很简单：因为当我们调用add1的时候，add1接收的参数其实是x的copy，而不是x本身。</p><p>如果真的需要传这个x本身,该怎么办呢？</p><p>这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有add1函数知道x变量所在的地址，才能修改x变量的值。所以我们需要将x所在地址&amp;x传入函数，并将函数的参数的类型由int改为*int，即改为指针类型，才能在函数中修改x变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//简单的一个函数，实现了参数+1的操作</span><br><span class="line">func add1(a *int) int &#123; // 请注意，</span><br><span class="line">*a = *a+1 // 修改了a的值</span><br><span class="line">return *a // 返回新值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">x := 3</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;x = &quot;, x)  // 应该输出 &quot;x = 3&quot;</span><br><span class="line"></span><br><span class="line">x1 := add1(&amp;x)  // 调用 add1(&amp;x) 传x的地址</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;x+1 = &quot;, x1) // 应该输出 &quot;x+1 = 4&quot;</span><br><span class="line">fmt.Println(&quot;x = &quot;, x)    // 应该输出 &quot;x = 4&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型 <em>T 是指向 T 类型值的指针，其零值为 nil; &amp; 操作符会生成一个指向其操作数的指针; </em> 操作符表示指针指向的底层值。</p><p>这样，就达到了修改x的目的。传指针的好处如下：</p></li><li>传指针使得多个函数能操作同一个对象。</li></ul><ul><li>传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。</li></ul><ul><li>Go语言中channel，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）</li></ul><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p> Go语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func ReadWrite() bool &#123;</span><br><span class="line">file.Open(&quot;file&quot;)</span><br><span class="line">// 做一些工作</span><br><span class="line">if failureX &#123;</span><br><span class="line">file.Close()</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if failureY &#123;</span><br><span class="line">file.Close()</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file.Close()</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 我们看到上面有很多重复的代码，Go的defer有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在defer后指定的函数会在函数退出前调用。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func ReadWrite() bool &#123;</span><br><span class="line">file.Open(&quot;file&quot;)</span><br><span class="line">defer file.Close()</span><br><span class="line">if failureX &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">if failureY &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用，所以如下代码会输出4 3 2 1 0<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">defer fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数作为值、类型"><a href="#函数作为值、类型" class="headerlink" title="函数作为值、类型"></a>函数作为值、类型</h3><p> 在Go中函数也是一种变量，我们可以通过type来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...])</span><br></pre></td></tr></table></figure><br> 函数作为类型到底有什么好处呢？那就是<em>可以把这个类型的函数当做值来传递</em>，请看下面的例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type testInt func(int) bool // 声明了一个函数类型</span><br><span class="line"></span><br><span class="line">func isOdd(integer int) bool &#123;</span><br><span class="line">if integer%2 == 0 &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isEven(integer int) bool &#123;</span><br><span class="line">if integer%2 == 0 &#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明的函数类型在这个地方当做了一个参数</span><br><span class="line"></span><br><span class="line">func filter(slice []int, f testInt) []int &#123;</span><br><span class="line">var result []int</span><br><span class="line">for _, value := range slice &#123;</span><br><span class="line">if f(value) &#123;</span><br><span class="line">result = append(result, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">slice := []int &#123;1, 2, 3, 4, 5, 7&#125;</span><br><span class="line">fmt.Println(&quot;slice = &quot;, slice)</span><br><span class="line">odd := filter(slice, isOdd)    // 函数当做值来传递了</span><br><span class="line">fmt.Println(&quot;Odd elements of slice are: &quot;, odd)</span><br><span class="line">even := filter(slice, isEven)  // 函数当做值来传递了</span><br><span class="line">fmt.Println(&quot;Even elements of slice are: &quot;, even)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 函数当做值和类型在我们写一些通用接口的时候非常有用，通过上面例子我们看到testInt这个类型是一个函数类型，然后两个filter函数的参数和返回值与testInt类型是一样的，但是我们可以实现很多种的逻辑，这样使得我们的程序变得非常的灵活。</p><h3 id="Panic和Recover"><a href="#Panic和Recover" class="headerlink" title="Panic和Recover"></a>Panic和Recover</h3><p> Go没有像Java那样的异常机制，它不能抛出异常，而是使用了panic和recover机制。一定要记住，你应当把它作为最后的手段来使用，也就是说，你的代码中应当没有，或者很少有panic的东西。这是个强大的工具，请明智地使用它。</p><p><strong>Panic</strong></p><blockquote><p>是一个内建函数，可以中断原有的控制流程，进入一个panic状态中。当函数F调用panic，函数F的执行被中断，但是F中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，F的行为就像调用了panic。这一过程继续向上，直到发生panic的goroutine中所有调用的函数返回，此时程序退出。panic可以直接调用panic产生。也可以由运行时错误产生，例如访问越界的数组。</p></blockquote><p><strong>Recover</strong></p><blockquote><p>是一个内建的函数，可以让进入panic状态的goroutine恢复过来。recover仅在延迟函数中有效。在正常的执行过程中，调用recover会返回nil，并且没有其它任何效果。如果当前的goroutine陷入panic状态，调用recover可以捕获到panic的输入值，并且恢复正常的执行。</p></blockquote><p> 下面这个函数演示了如何在过程中使用panic:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var user = os.Getenv(&quot;USER&quot;)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">if user == &quot;&quot; &#123;</span><br><span class="line">panic(&quot;no value for $USER&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 下面这个函数检查作为其参数的函数在执行时是否会产生panic：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func throwsPanic(f func()) (b bool) &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">if x := recover(); x != nil &#123;</span><br><span class="line">b = true</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">f() //执行函数f，如果f中出现了panic，那么就可以恢复回来</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="main函数和init函数"><a href="#main函数和init函数" class="headerlink" title="main函数和init函数"></a>main函数和init函数</h3><p> Go里面有两个保留的函数：init函数（能够应用于所有的<code>package</code>）和<code>main</code>函数（只能应用于<code>package main</code>）。这两个函数在定义时不能有任何的参数和返回值。虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个<code>package</code>中每个文件只写一个<code>init</code>函数。</p><p> Go程序会自动调用<code>init()</code>和<code>main()</code>，所以你不需要在任何地方调用这两个函数。每个<code>package</code>中的<code>init</code>函数都是可选的，但<code>package main</code>就必须包含一个main函数。</p><p> 程序的初始化和执行都起始于<code>main</code>包。如果<code>main</code>包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到<code>fmt</code>包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行<code>init</code>函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行<code>main</code>包中的<code>init</code>函数（如果存在的话），最后执行<code>main</code>函数。下图详细地解释了整个执行过程：</p><p><img src="https://z3.ax1x.com/2021/11/22/IvXTbj.png" alt="main函数引入包初始化流程图"></p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p> 写Go代码的时候经常用到<code>import</code>这个命令用来导入包文件，而我们经常看到的方式参考如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br> 然后我们代码里面可以通过如下的方式调用:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure><br> 上面展示了一些<code>import</code>常用的几种方式，但是还有一些特殊的<code>import</code>，例如：</p><p>1.点操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">    . &quot;fmt&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的<code>fmt.Println(&quot;hello world&quot;)</code>可以省略的写成<code>Println(&quot;hello world&quot;)</code></p><p>2.别名操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">    f &quot;fmt&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字,调用包函数时前缀变成了我们的前缀，即f.Println(“hello world”)</p><p>3._操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;database/sql&quot;</span><br><span class="line">    _ &quot;github.com/ziutek/mymysql/godrv&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> _操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。</p><h1 id="struct类型"><a href="#struct类型" class="headerlink" title="struct类型"></a>struct类型</h1><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p> Go语言中，也和C或者其他语言一样，我们可以声明新的类型，作为其它类型的属性或字段的容器。例如，我们可以创建一个自定义类型<code>person</code>代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型我们称之<code>struct</code>。如下代码所示:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">age int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 声明一个struct很简单，上面的类型包含有两个字段：</p><ul><li>一个string类型的字段name，用来保存用户名称这个属性</li></ul><ul><li>一个int类型的字段age,用来保存用户年龄这个属性</li></ul><p>关于struct的使用请看下面的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var P person  // P现在就是person类型的变量了</span><br><span class="line"></span><br><span class="line">P.name = &quot;Astaxie&quot;  // 赋值&quot;Astaxie&quot;给P的name属性.</span><br><span class="line">P.age = 25  // 赋值&quot;25&quot;给变量P的age属性</span><br><span class="line">fmt.Printf(&quot;The person&#x27;s name is %s&quot;, P.name)  // 访问P的name属性.</span><br></pre></td></tr></table></figure><br> 除了上面这种P的声明使用之外，还有另外几种声明使用方式：</p><ul><li><p>按照顺序提供初始化值</p><p><code>P := person&#123;&quot;Tom&quot;, 25&#125;</code></p></li></ul><ul><li><p>通过<code>field:value</code>的方式初始化，这样可以任意顺序</p><p><code>P := person&#123;age:24, name:&quot;Tom&quot;&#125;</code></p></li></ul><ul><li><p>当然也可以通过<code>new</code>函数分配一个指针，此处P的类型为<code>*person</code></p><p><code>P := new(person)</code></p></li></ul><p>下面看一个完整的使用struct的例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 声明一个新的类型</span><br><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差</span><br><span class="line">// struct也是传值的</span><br><span class="line">func Older(p1, p2 person) (person, int) &#123;</span><br><span class="line">if p1.age&gt;p2.age &#123;  // 比较p1和p2这两个人的年龄</span><br><span class="line">return p1, p1.age-p2.age</span><br><span class="line">&#125;</span><br><span class="line">return p2, p2.age-p1.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var tom person</span><br><span class="line"></span><br><span class="line">// 赋值初始化</span><br><span class="line">tom.name, tom.age = &quot;Tom&quot;, 18</span><br><span class="line"></span><br><span class="line">// 两个字段都写清楚的初始化</span><br><span class="line">bob := person&#123;age:25, name:&quot;Bob&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 按照struct定义顺序初始化值</span><br><span class="line">paul := person&#123;&quot;Paul&quot;, 43&#125;</span><br><span class="line"></span><br><span class="line">tb_Older, tb_diff := Older(tom, bob)</span><br><span class="line">tp_Older, tp_diff := Older(tom, paul)</span><br><span class="line">bp_Older, bp_diff := Older(bob, paul)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;Of %s and %s, %s is older by %d years\n&quot;,</span><br><span class="line">tom.name, bob.name, tb_Older.name, tb_diff)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;Of %s and %s, %s is older by %d years\n&quot;,</span><br><span class="line">tom.name, paul.name, tp_Older.name, tp_diff)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;Of %s and %s, %s is older by %d years\n&quot;,</span><br><span class="line">bob.name, paul.name, bp_Older.name, bp_diff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="struct的匿名字段"><a href="#struct的匿名字段" class="headerlink" title="struct的匿名字段"></a>struct的匿名字段</h3><p> 上面介绍了如何定义一个<code>struct</code>，定义的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。</p><p> 当匿名字段是一个<code>struct</code>的时候，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的这个<code>struct</code>。</p><p> 让我们来看一个例子，让上面说的这些更具体化：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">name string</span><br><span class="line">age int</span><br><span class="line">weight int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Human  // 匿名字段，那么默认Student就包含了Human的所有字段</span><br><span class="line">speciality string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 我们初始化一个学生</span><br><span class="line">mark := Student&#123;Human&#123;&quot;Mark&quot;, 25, 120&#125;, &quot;Computer Science&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 我们访问相应的字段</span><br><span class="line">fmt.Println(&quot;His name is &quot;, mark.name)</span><br><span class="line">fmt.Println(&quot;His age is &quot;, mark.age)</span><br><span class="line">fmt.Println(&quot;His weight is &quot;, mark.weight)</span><br><span class="line">fmt.Println(&quot;His speciality is &quot;, mark.speciality)</span><br><span class="line">// 修改对应的备注信息</span><br><span class="line">mark.speciality = &quot;AI&quot;</span><br><span class="line">fmt.Println(&quot;Mark changed his speciality&quot;)</span><br><span class="line">fmt.Println(&quot;His speciality is &quot;, mark.speciality)</span><br><span class="line">// 修改他的年龄信息</span><br><span class="line">fmt.Println(&quot;Mark become old&quot;)</span><br><span class="line">mark.age = 46</span><br><span class="line">fmt.Println(&quot;His age is&quot;, mark.age)</span><br><span class="line">// 修改他的体重信息</span><br><span class="line">fmt.Println(&quot;Mark is not an athlet anymore&quot;)</span><br><span class="line">mark.weight += 60</span><br><span class="line">fmt.Println(&quot;His weight is&quot;, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 图例如下:</p><p><img src="https://z3.ax1x.com/2021/11/22/Izih5D.png" alt="struct组合，Student组合了Human struct和string基本类型"></p><p> 我们看到<code>Student</code>访问属性<code>age</code>和<code>name</code>的时候，就像访问自己所有用的字段一样，对，匿名字段就是这样，能够实现字段的继承。比这个更酷的就是<code>student</code>还能访问<code>Human</code>这个字段作为字段名。请看下面的代码，是不是更酷了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mark.Human = Human&#123;&quot;Marcus&quot;, 55, 220&#125;</span><br><span class="line">mark.Human.age -= 1</span><br></pre></td></tr></table></figure><br> 通过匿名访问和修改字段相当的有用，但是不仅仅是struct字段哦，所有的内置类型和自定义类型都是可以作为匿名字段的。请看下面的例子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Skills []string</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">name string</span><br><span class="line">age int</span><br><span class="line">weight int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Human  // 匿名字段，struct</span><br><span class="line">Skills // 匿名字段，自定义的类型string slice</span><br><span class="line">int    // 内置类型作为匿名字段</span><br><span class="line">speciality string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 初始化学生Jane</span><br><span class="line">jane := Student&#123;Human:Human&#123;&quot;Jane&quot;, 35, 100&#125;, speciality:&quot;Biology&quot;&#125;</span><br><span class="line">// 现在我们来访问相应的字段</span><br><span class="line">fmt.Println(&quot;Her name is &quot;, jane.name)</span><br><span class="line">fmt.Println(&quot;Her age is &quot;, jane.age)</span><br><span class="line">fmt.Println(&quot;Her weight is &quot;, jane.weight)</span><br><span class="line">fmt.Println(&quot;Her speciality is &quot;, jane.speciality)</span><br><span class="line">// 我们来修改他的skill技能字段</span><br><span class="line">jane.Skills = []string&#123;&quot;anatomy&quot;&#125;</span><br><span class="line">fmt.Println(&quot;Her skills are &quot;, jane.Skills)</span><br><span class="line">fmt.Println(&quot;She acquired two new ones &quot;)</span><br><span class="line">jane.Skills = append(jane.Skills, &quot;physics&quot;, &quot;golang&quot;)</span><br><span class="line">fmt.Println(&quot;Her skills now are &quot;, jane.Skills)</span><br><span class="line">// 修改匿名内置类型字段</span><br><span class="line">jane.int = 3</span><br><span class="line">fmt.Println(&quot;Her preferred number is&quot;, jane.int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 从上面例子我们看出来struct不仅仅能够将struct作为匿名字段，自定义类型、内置类型都可以作为匿名字段，而且可以在相应的字段上面进行函数操作（如例子中的append）。</p><p> 这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？</p><p> Go里面很简单的解决了这个问题，最外层的优先访问，也就是当你通过<code>student.phone</code>访问的时候，是访问<code>student</code>里面的字段，而不是<code>human</code>里面的字段。</p><p> 这样就允许我们去重载通过匿名字段继承的一些字段，当然如果我们想访问重载后对应匿名类型里面的字段，可以通过匿名字段名来访问。请看下面的例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">name string</span><br><span class="line">age int</span><br><span class="line">phone string  // Human类型拥有的字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">Human  // 匿名字段Human</span><br><span class="line">speciality string</span><br><span class="line">phone string  // 雇员的phone字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">Bob := Employee&#123;Human&#123;&quot;Bob&quot;, 34, &quot;777-444-XXXX&quot;&#125;, &quot;Designer&quot;, &quot;333-222&quot;&#125;</span><br><span class="line">fmt.Println(&quot;Bob&#x27;s work phone is:&quot;, Bob.phone)</span><br><span class="line">// 如果我们要访问Human的phone字段</span><br><span class="line">fmt.Println(&quot;Bob&#x27;s personal phone is:&quot;, Bob.Human.phone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p> 是否想过函数当作struct的字段一样来处理呢？我们可以看一下函数的另一种形态，带有接收者的函数，称为<code>method</code></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p> 假设有这么一个场景，你定义了一个struct叫做长方形，你现在想要计算他的面积，那么按照我们一般的思路应该会用下面的方式来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Rectangle struct &#123;</span><br><span class="line">width, height float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func area(r Rectangle) float64 &#123;</span><br><span class="line">return r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">r1 := Rectangle&#123;12, 2&#125;</span><br><span class="line">r2 := Rectangle&#123;9, 4&#125;</span><br><span class="line">fmt.Println(&quot;Area of r1 is: &quot;, area(r1))</span><br><span class="line">fmt.Println(&quot;Area of r2 is: &quot;, area(r2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 这段代码可以计算出来长方形的面积，但是area()不是作为Rectangle的方法实现的（类似面向对象里面的方法），而是将Rectangle的对象（如r1,r2）作为参数传入函数计算面积的。</p><p> 这样实现当然没有问题咯，但是当需要增加圆形、正方形、五边形甚至其它多边形的时候，你想计算他们的面积的时候怎么办啊？那就只能增加新的函数咯，但是函数名你就必须要跟着换了，变成area_rectangle, area_circle, area_triangle…</p><p> 像下图所表示的那样， 椭圆代表函数, 而这些函数并不从属于struct(或者以面向对象的术语来说，并不属于class)，他们是单独存在于struct外围，而非在概念上属于某个struct的。</p><p><img src="https://z3.ax1x.com/2021/11/23/oSol9S.png" alt="方法和struct的关系图"></p><p> 很显然，这样的实现并不优雅，并且从概念上来说”面积”是”形状”的一个属性，它是属于这个特定的形状的，就像长方形的长和宽一样。</p><p> 基于上面的原因所以就有了<code>method</code>的概念，method是附属在一个给定的类型上的，他的语法和函数的声明语法几乎一样，只是在func后面增加了一个receiver(也就是method所依从的主体)。</p><p> 用上面提到的形状的例子来说，<code>method area()</code>是依赖于某个形状(比如说Rectangle)来发生作用的。Rectangle.area()的发出者是Rectangle， area()是属于Rectangle的方法，而非一个外围函数。</p><p> 更具体地说，Rectangle存在字段 height 和 width, 同时存在方法area(), 这些字段和方法都属于Rectangle。</p><p> 用Rob Pike的话来说就是：</p><blockquote><p>func (r ReceiverType) funcName(parameters) (results)</p></blockquote><p> method的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (r ReceiverType) funcName(parameters) (results)</span><br></pre></td></tr></table></figure><br> 下面我们用最开始的例子用method来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Rectangle struct &#123;</span><br><span class="line">width, height float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Circle struct &#123;</span><br><span class="line">radius float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Rectangle) area() float64 &#123;</span><br><span class="line">return r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c Circle) area() float64 &#123;</span><br><span class="line">return c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">r1 := Rectangle&#123;12, 2&#125;</span><br><span class="line">r2 := Rectangle&#123;9, 4&#125;</span><br><span class="line">c1 := Circle&#123;10&#125;</span><br><span class="line">c2 := Circle&#123;25&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;Area of r1 is: &quot;, r1.area())</span><br><span class="line">fmt.Println(&quot;Area of r2 is: &quot;, r2.area())</span><br><span class="line">fmt.Println(&quot;Area of c1 is: &quot;, c1.area())</span><br><span class="line">fmt.Println(&quot;Area of c2 is: &quot;, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 在使用method的时候重要注意几点:</p><ul><li>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</li></ul><ul><li>method里面可以访问接收者的字段</li></ul><ul><li><p>调用method通过<code>.</code>访问，就像struct里面访问字段一样</p><p>图示如下:</p></li></ul><p><img src="https://z3.ax1x.com/2021/11/23/oSTjd1.png" alt="不同struct的method不同"></p><p> 在上例，method area() 分别属于Rectangle和Circle， 于是他们的 Receiver 就变成了Rectangle 和 Circle, 或者说，这个area()方法 是由 Rectangle/Circle 发出的。</p><blockquote><p>值得说明的一点是，图示中method用虚线标出，意思是此处方法的Receiver是以值传递，而非引用传递，是的，Receiver还可以是指针, 两者的差别在于, 指针作为Receiver会对实例对象的内容发生操作,而普通类型作为Receiver仅仅是以副本作为操作对象,并不对原实例对象发生操作。后文对此会有详细论述。</p></blockquote><p> 那是不是method只能作用在struct上面呢？当然不是，它可以定义在任何你自定义的类型、内置类型、struct等各种类型上面。这里你是不是有点迷糊了，什么叫自定义类型，自定义类型不就是struct嘛，不是这样的哦，struct只是自定义类型里面一种比较特殊的类型而已，还有其他自定义类型申明，可以通过如下这样的申明来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type typeName typeLiteral</span><br></pre></td></tr></table></figure><br> 下面是这个申明自定义类型的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type ages int</span><br><span class="line"></span><br><span class="line">type money float32</span><br><span class="line"></span><br><span class="line">type months map[string]int</span><br><span class="line"></span><br><span class="line">m := months &#123;</span><br><span class="line">&quot;January&quot;:31,</span><br><span class="line">&quot;February&quot;:28,</span><br><span class="line">...</span><br><span class="line">&quot;December&quot;:31,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 你可以在自己的代码里面定义有意义的类型，实际上只是一个定义了一个别名,有点类似于c中的typedef，例如上面ages替代了int</p><p> 你可以在任何的自定义类型中定义任意多的<code>method</code>，接下来让我们看一个复杂一点的例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">const(</span><br><span class="line">WHITE = iota //+1</span><br><span class="line">BLACK</span><br><span class="line">BLUE</span><br><span class="line">RED</span><br><span class="line">YELLOW</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Color byte</span><br><span class="line"></span><br><span class="line">type Box struct &#123;</span><br><span class="line">width, height, depth float64</span><br><span class="line">color Color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BoxList []Box //a slice of boxes</span><br><span class="line"></span><br><span class="line">func (b Box) Volume() float64 &#123;</span><br><span class="line">return b.width * b.height * b.depth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Box) SetColor(c Color) &#123;</span><br><span class="line">b.color = c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (bl BoxList) BiggestColor() Color &#123;</span><br><span class="line">v := 0.00</span><br><span class="line">k := Color(WHITE)</span><br><span class="line">for _, b := range bl &#123;</span><br><span class="line">if bv := b.Volume(); bv &gt; v &#123;</span><br><span class="line">v = bv</span><br><span class="line">k = b.color</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (bl BoxList) PaintItBlack() &#123;</span><br><span class="line">for i := range bl &#123;</span><br><span class="line">bl[i].SetColor(BLACK)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c Color) String() string &#123;</span><br><span class="line">strings := []string &#123;&quot;WHITE&quot;, &quot;BLACK&quot;, &quot;BLUE&quot;, &quot;RED&quot;, &quot;YELLOW&quot;&#125;</span><br><span class="line">return strings[c]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">boxes := BoxList &#123;</span><br><span class="line">Box&#123;4, 4, 4, RED&#125;,</span><br><span class="line">Box&#123;10, 10, 1, YELLOW&#125;,</span><br><span class="line">Box&#123;1, 1, 20, BLACK&#125;,</span><br><span class="line">Box&#123;10, 10, 1, BLUE&#125;,</span><br><span class="line">Box&#123;10, 30, 1, WHITE&#125;,</span><br><span class="line">Box&#123;20, 20, 20, YELLOW&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;We have %d boxes in our set\n&quot;, len(boxes))</span><br><span class="line">fmt.Println(&quot;The volume of the first one is&quot;, boxes[0].Volume(), &quot;cm³&quot;)</span><br><span class="line">fmt.Println(&quot;The color of the last one is&quot;,boxes[len(boxes)-1].color.String())</span><br><span class="line">fmt.Println(&quot;The biggest one is&quot;, boxes.BiggestColor().String())</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;Let&#x27;s paint them all black&quot;)</span><br><span class="line">boxes.PaintItBlack()</span><br><span class="line">fmt.Println(&quot;The color of the second one is&quot;, boxes[1].color.String())</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;Obviously, now, the biggest one is&quot;, boxes.BiggestColor().String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 上面的代码通过const定义了一些常量，然后定义了一些自定义类型:</p><ul><li>Color作为byte的别名</li></ul><ul><li>定义了一个struct:Box，含有三个长宽高字段和一个颜色属性</li></ul><ul><li><p>定义了一个slice:BoxList，含有Box</p><p>然后以上面的自定义类型为接收者定义了一些method:</p></li><li>Volume()定义了接收者为Box，返回Box的容量</li></ul><ul><li>SetColor(c Color)，把Box的颜色改为c</li></ul><ul><li>BiggestColor()定在在BoxList上面，返回list里面容量最大的颜色</li></ul><ul><li>PaintItBlack()把BoxList里面所有Box的颜色全部变成黑色</li></ul><ul><li>String()定义在Color上面，返回Color的具体颜色(字符串格式)</li></ul><h3 id="指针作为receiver"><a href="#指针作为receiver" class="headerlink" title="指针作为receiver"></a>指针作为receiver</h3><p> 现在让我们回过头来看看SetColor这个method，它的receiver是一个指向Box的指针，是的，你可以使用*Box。想想为什么要使用指针而不是Box本身呢？</p><p> 我们定义SetColor的真正目的是想改变这个Box的颜色，如果不传Box的指针，那么SetColor接受的其实是Box的一个copy，也就是说method内对于颜色值的修改，其实只作用于Box的copy，而不是真正的Box。所以我们需要传入指针。</p><p> 这里可以把receiver当作method的第一个参数来看，然后结合前面函数讲解的传值和传引用就不难理解</p><p> 这里你也许会问了那SetColor函数里面应该这样定义<code>*b.Color=c</code>,而不是<code>b.Color=c</code>,因为我们需要读取到指针相应的值。</p><p> 你是对的，其实Go里面这两种方式都是正确的，当你用指针去访问相应的字段时(虽然指针没有任何的字段)，Go知道你要通过指针去获取这个值，看到了吧，Go的设计是不是越来越吸引你了。</p><p> 也许细心的读者会问这样的问题，PaintItBlack里面调用SetColor的时候是不是应该写成<code>(&amp;bl[i]).SetColor(BLACK)</code>，因为SetColor的receiver是*Box，而不是Box。</p><p> 你又说对了，这两种方式都可以，因为Go知道receiver是指针，他自动帮你转了。</p><p> 也就是说：</p><blockquote><p>如果一个method的receiver是*T,你可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method</p></blockquote><p> 类似的</p><blockquote><p>如果一个method的receiver是T，你可以在一个<em>T类型的变量P上面调用这个method，而不需要 </em>P去调用这个method</p></blockquote><h3 id="method继承"><a href="#method继承" class="headerlink" title="method继承"></a>method继承</h3><p> method也是可以继承的。如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method。让我们来看下面这个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">name string</span><br><span class="line">age int</span><br><span class="line">phone string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Human //匿名字段</span><br><span class="line">school string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">Human //匿名字段</span><br><span class="line">company string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在human上面定义了一个method</span><br><span class="line">func (h *Human) SayHi() &#123;</span><br><span class="line">fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">mark := Student&#123;Human&#123;&quot;Mark&quot;, 25, &quot;222-222-YYYY&quot;&#125;, &quot;MIT&quot;&#125;</span><br><span class="line">sam := Employee&#123;Human&#123;&quot;Sam&quot;, 45, &quot;111-888-XXXX&quot;&#125;, &quot;Golang Inc&quot;&#125;</span><br><span class="line"></span><br><span class="line">mark.SayHi()</span><br><span class="line">sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="method重写"><a href="#method重写" class="headerlink" title="method重写"></a>method重写</h3><p> 上面的例子中，如果Employee想要实现自己的SayHi,怎么办？很简单，和匿名字段冲突一样的道理，我们可以在Employee上面定义一个method，重写了匿名字段的方法。请看下面的例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">name string</span><br><span class="line">age int</span><br><span class="line">phone string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Human //匿名字段</span><br><span class="line">school string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">Human //匿名字段</span><br><span class="line">company string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Human定义method</span><br><span class="line">func (h *Human) SayHi() &#123;</span><br><span class="line">fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Employee的method重写Human的method</span><br><span class="line">func (e *Employee) SayHi() &#123;</span><br><span class="line">fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;, e.name,</span><br><span class="line">e.company, e.phone) //Yes you can split into 2 lines here.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">mark := Student&#123;Human&#123;&quot;Mark&quot;, 25, &quot;222-222-YYYY&quot;&#125;, &quot;MIT&quot;&#125;</span><br><span class="line">sam := Employee&#123;Human&#123;&quot;Sam&quot;, 45, &quot;111-888-XXXX&quot;&#125;, &quot;Golang Inc&quot;&#125;</span><br><span class="line"></span><br><span class="line">mark.SayHi()</span><br><span class="line">sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 通过这些内容，我们可以设计出基本的面向对象的程序了，但是Go里面的面向对象是如此的简单，没有任何的私有、公有关键字，通过大小写来实现(大写开头的为公有，小写开头的为私有)，方法也同样适用这个原则。</p><h1 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h1><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p> Go语言里面设计最精妙的应该算interface，它让面向对象、内容组织实现的非常方便，当你看完这一幕，你就会被interface的精妙所折服。</p><h3 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h3><p> 简单的说，interface是一组method签名的组合，我们通过interface来定义对象的一组行为。</p><p> 我们前面一章最后一个例子中Student和Employee都能SayHi，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能say hi</p><p> 让我们来继续做更多的扩展，Student和Employee实现另一个方法Sing，然后Student实现方法BorrowMoney而Employee实现SpendSalary。</p><p> 这样Student实现了三个方法：SayHi、Sing、BorrowMoney；而Employee实现了SayHi、Sing、SpendSalary。</p><p> 上面这些方法的组合称为interface(被对象Student和Employee实现)。例如Student和Employee都实现了interface：SayHi和Sing，也就是这两个对象是该interface类型。而Employee没有实现这个interface：SayHi、Sing和BorrowMoney，因为Employee没有实现BorrowMoney这个方法。</p><h3 id="interface-1"><a href="#interface-1" class="headerlink" title="interface"></a>interface</h3><p> interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">type Human struct &#123;</span><br><span class="line">name string</span><br><span class="line">age int</span><br><span class="line">phone string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Human //匿名字段Human</span><br><span class="line">school string</span><br><span class="line">loan float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">Human //匿名字段Human</span><br><span class="line">company string</span><br><span class="line">money float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Human对象实现Sayhi方法</span><br><span class="line">func (h *Human) SayHi() &#123;</span><br><span class="line">fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Human对象实现Sing方法</span><br><span class="line">func (h *Human) Sing(lyrics string) &#123;</span><br><span class="line">fmt.Println(&quot;La la, la la la, la la la la la...&quot;, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Human对象实现Guzzle方法</span><br><span class="line">func (h *Human) Guzzle(beerStein string) &#123;</span><br><span class="line">fmt.Println(&quot;Guzzle Guzzle Guzzle...&quot;, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Employee重载Human的Sayhi方法</span><br><span class="line">func (e *Employee) SayHi() &#123;</span><br><span class="line">fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;, e.name,</span><br><span class="line">e.company, e.phone) //此句可以分成多行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Student实现BorrowMoney方法</span><br><span class="line">func (s *Student) BorrowMoney(amount float32) &#123;</span><br><span class="line">s.loan += amount // (again and again and...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Employee实现SpendSalary方法</span><br><span class="line">func (e *Employee) SpendSalary(amount float32) &#123;</span><br><span class="line">e.money -= amount // More vodka please!!! Get me through the day!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义interface</span><br><span class="line">type Men interface &#123;</span><br><span class="line">SayHi()</span><br><span class="line">Sing(lyrics string)</span><br><span class="line">Guzzle(beerStein string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type YoungChap interface &#123;</span><br><span class="line">SayHi()</span><br><span class="line">Sing(song string)</span><br><span class="line">BorrowMoney(amount float32)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ElderlyGent interface &#123;</span><br><span class="line">SayHi()</span><br><span class="line">Sing(song string)</span><br><span class="line">SpendSalary(amount float32)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 通过上面的代码我们可以知道，interface可以被任意的对象实现。我们看到上面的Men interface被Human、Student和Employee实现。同理，一个对象可以实现任意多个interface，例如上面的Student实现了Men和YoungChap两个interface。</p><p> 最后，任意的类型都实现了空interface(我们这样定义：interface{})，也就是包含0个method的interface。</p><h3 id="interface值"><a href="#interface值" class="headerlink" title="interface值"></a>interface值</h3><p> 那么interface里面到底能存什么值呢？如果我们定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，我们定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值。</p><p> 因为m能够持有这三种类型的对象，所以我们可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了Men接口的任意结构的对象，这个和我们传统意义上面的slice有所不同。</p><p> 让我们来看一下下面这个例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">name string</span><br><span class="line">age int</span><br><span class="line">phone string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Human //匿名字段</span><br><span class="line">school string</span><br><span class="line">loan float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">Human //匿名字段</span><br><span class="line">company string</span><br><span class="line">money float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Human实现SayHi方法</span><br><span class="line">func (h Human) SayHi() &#123;</span><br><span class="line">fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Human实现Sing方法</span><br><span class="line">func (h Human) Sing(lyrics string) &#123;</span><br><span class="line">fmt.Println(&quot;La la la la...&quot;, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Employee重载Human的SayHi方法</span><br><span class="line">func (e Employee) SayHi() &#123;</span><br><span class="line">fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;, e.name,</span><br><span class="line">e.company, e.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Interface Men被Human,Student和Employee实现</span><br><span class="line">// 因为这三个类型都实现了这两个方法</span><br><span class="line">type Men interface &#123;</span><br><span class="line">SayHi()</span><br><span class="line">Sing(lyrics string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">mike := Student&#123;Human&#123;&quot;Mike&quot;, 25, &quot;222-222-XXX&quot;&#125;, &quot;MIT&quot;, 0.00&#125;</span><br><span class="line">paul := Student&#123;Human&#123;&quot;Paul&quot;, 26, &quot;111-222-XXX&quot;&#125;, &quot;Harvard&quot;, 100&#125;</span><br><span class="line">sam := Employee&#123;Human&#123;&quot;Sam&quot;, 36, &quot;444-222-XXX&quot;&#125;, &quot;Golang Inc.&quot;, 1000&#125;</span><br><span class="line">tom := Employee&#123;Human&#123;&quot;Tom&quot;, 37, &quot;222-444-XXX&quot;&#125;, &quot;Things Ltd.&quot;, 5000&#125;</span><br><span class="line"></span><br><span class="line">//定义Men类型的变量i</span><br><span class="line">var i Men</span><br><span class="line"></span><br><span class="line">//i能存储Student</span><br><span class="line">i = mike</span><br><span class="line">fmt.Println(&quot;This is Mike, a Student:&quot;)</span><br><span class="line">i.SayHi()</span><br><span class="line">i.Sing(&quot;November rain&quot;)</span><br><span class="line"></span><br><span class="line">//i也能存储Employee</span><br><span class="line">i = tom</span><br><span class="line">fmt.Println(&quot;This is tom, an Employee:&quot;)</span><br><span class="line">i.SayHi()</span><br><span class="line">i.Sing(&quot;Born to be wild&quot;)</span><br><span class="line"></span><br><span class="line">//定义了slice Men</span><br><span class="line">fmt.Println(&quot;Let&#x27;s use a slice of Men and see what happens&quot;)</span><br><span class="line">x := make([]Men, 3)</span><br><span class="line">//这三个都是不同类型的元素，但是他们实现了interface同一个接口</span><br><span class="line">x[0], x[1], x[2] = paul, sam, mike</span><br><span class="line"></span><br><span class="line">for _, value := range x&#123;</span><br><span class="line">value.SayHi()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 通过上面的代码，你会发现interface就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实现， Go通过interface实现了duck-typing:即”当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。</p><h3 id="空interface"><a href="#空interface" class="headerlink" title="空interface"></a>空interface</h3><p> 空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义a为空接口</span><br><span class="line">var a interface&#123;&#125;</span><br><span class="line">var i int = 5</span><br><span class="line">s := &quot;Hello world&quot;</span><br><span class="line">// a可以存储任意类型的数值</span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure><br> 一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值!</p><h3 id="interface函数参数"><a href="#interface函数参数" class="headerlink" title="interface函数参数"></a>interface函数参数</h3><p> interface的变量可以持有任意实现该interface类型的对象，这给我们编写函数(包括method)提供了一些额外的思考，我们是不是可以通过定义interface参数，让函数接受各种类型的参数。</p><p> 举个例子：fmt.Println是我们常用的一个函数，但是你是否注意到它可以接受任意类型的数据。打开fmt的源码文件，你会看到这样一个定义:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line"> String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 也就是说，任何实现了String方法的类型都能作为参数被fmt.Println调用:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Human struct &#123;</span><br><span class="line">name string</span><br><span class="line">age int</span><br><span class="line">phone string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过这个方法 Human 实现了 fmt.Stringer</span><br><span class="line">func (h Human) String() string &#123;</span><br><span class="line">return &quot;❰&quot;+h.name+&quot; - &quot;+strconv.Itoa(h.age)+&quot; years -  ✆ &quot; +h.phone+&quot;❱&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">Bob := Human&#123;&quot;Bob&quot;, 39, &quot;000-7777-XXX&quot;&#125;</span><br><span class="line">fmt.Println(&quot;This Human is : &quot;, Bob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 现在我们再回顾一下前面的Box示例，你会发现Color结构也定义了一个method：String。其实这也是实现了fmt.Stringer这个interface，即如果需要某个类型能被fmt包以特殊的格式输出，你就必须实现Stringer这个接口。如果没有实现这个接口，fmt将以默认的方式输出。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//实现同样的功能</span><br><span class="line">fmt.Println(&quot;The biggest one is&quot;, boxes.BiggestsColor().String())</span><br><span class="line">fmt.Println(&quot;The biggest one is&quot;, boxes.BiggestsColor())</span><br></pre></td></tr></table></figure></p><blockquote><p>注：实现了error接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。</p></blockquote><h1 id="终结（Java-ing…）"><a href="#终结（Java-ing…）" class="headerlink" title="终结（Java ing…）"></a>终结（Java ing…）</h1><h1 id="学习参考资料"><a href="#学习参考资料" class="headerlink" title="学习参考资料"></a>学习参考资料</h1><ul><li><a href="http://tour.studygolang.com/flowcontrol/1">Go指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning to Group and Label Fine-Grained Shape Components</title>
      <link href="/post/post1.html"/>
      <url>/post/post1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Learning-to-Group-and-Label-Fine-Grained-Shape-Components-学习对细粒度形状组件进行分组和标记"><a href="#Learning-to-Group-and-Label-Fine-Grained-Shape-Components-学习对细粒度形状组件进行分组和标记" class="headerlink" title="Learning to Group and Label Fine-Grained Shape Components(学习对细粒度形状组件进行分组和标记)"></a>Learning to Group and Label Fine-Grained Shape Components(学习对细粒度形状组件进行分组和标记)</h1><h2 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h2><p><em>细粒度</em>：细粒度模型,通俗的讲就是将业务模型中的对象加以细分,从而得到更科学合理的对象模型,直观的说就是划分出很多对象</p><p><em>CRF</em>：条件随机域（场）（conditional random fields），是一种判别式概率模型，是在给定一组输入随机变量条件下另外一组输出随机变量的条件概率分布模型，它是一种判别式的概率无向图模型，既然是判别式，那就是对条件概率分布建模。常用于标注或分析序列资料，如自然语言文字或是生物序列。</p><p><em>语义</em>：简称部分，指语义独立或功能完整的组件组。</p><p><em>ablation studies</em>：消融研究，通常是指删除模型或算法的某些“特征”，并观察其如何影响性能。</p><p><em>MCL</em>：多分量标记</p><h2 id="概述部分思路"><a href="#概述部分思路" class="headerlink" title="概述部分思路"></a>概述部分思路</h2><hr><p><strong>现状</strong>：</p><ul><li>在建模过程中需考虑一些基于功能的形状分解;</li><li>功能组件通常被过度分割，导致被建模为多组件;</li></ul><div class="mermaid">flowchart LR    分层分组策略 --&gt; 零件假设    多尺度三维CNN--&gt;提取假设的上下文感知特征</div><hr><p><strong>目的</strong>：完成整个形状的标记分割</p><div class="mermaid">flowchart LR    高阶CRF--&gt;推断所有组件的最佳标记分配</div><p><strong>结果</strong>：在公共形状存储库中的原始三维模型上实现了显著稳健的标记结果。</p><hr><h2 id="简介部分思路"><a href="#简介部分思路" class="headerlink" title="简介部分思路"></a>简介部分思路</h2><p><strong>现状</strong>：</p><ul><li>现有方法（深层学习网络处理3D形状的语义或标记分割），一直在处理流形网格、点云或体积，面对现今大多数多达数百个高细粒度的模型很难处理；</li><li>常用的多视图投影分割不能够处理具有严重自遮挡的形状；</li><li><p>股票模型组件：</p><p>1.模型分解高度细粒度；</p><p>2.组件大小差异大；</p><p>3.不同建模者可能对形状组合有不一样的看法；</p></li></ul><p>因此，直接描述单个部件的形状进行标记不可靠</p><p><strong>任务</strong>：<br><div class="mermaid">flowchart LR    标记真实部分假设并修剪错误假设--&gt;CNN从零件假设体积中提取特征    CNN从零件假设体积中提取特征--&gt;捕获局部零件几何图形    CNN从零件假设体积中提取特征--&gt;捕获全局上下文信息特征    捕获全局上下文信息特征--&gt;高阶CRF推断单个组件最佳标记分配    捕获局部零件几何图形--&gt;高阶CRF推断单个组件最佳标记分配</div><br><strong>效果</strong>：实现了高度精确的标记，同时节省了为训练准备大量高阶关系数据的工作量。</p><p><strong>总结</strong>：提出一种多尺度3D CNN，用于编码局部和上下文信息以及零件假设标记，并基于CRF的组件标记公式建立多组分标签基准，做出广泛评估。</p><hr><h2 id="相关工作部分思路"><a href="#相关工作部分思路" class="headerlink" title="相关工作部分思路"></a>相关工作部分思路</h2><p><strong>现有技术问题分析</strong>：大多基于对输入形状的过度分割，然后进行分组处理，形成语义分割和标记。</p><hr><h2 id="关键技术部分思路"><a href="#关键技术部分思路" class="headerlink" title="关键技术部分思路"></a>关键技术部分思路</h2><h3 id="三个算法组件"><a href="#三个算法组件" class="headerlink" title="三个算法组件"></a>三个算法组件</h3><ul><li><strong>部件假设生成</strong>：寻找零件假设时，遵循以下两个原则</li></ul><ol><li>一个部分假设应涵盖尽可能多的相应基础真相部分的组成 ；</li><li>部件假设的部件覆盖率应是保守的；</li></ol><p><img src="https://z3.ax1x.com/2021/11/05/IKZFIg.png" alt=""></p><p>分层分组策略：</p><p>三个启发式标准（自底向上执行）：</p><ol><li><strong>中心距离标准</strong>：测量两个组件A和B之间的紧密度（它测量两个组件的凸包重心之间的距离，并鼓励对空间上彼此接近的组件进行分组。）</li><li><strong>几何接触准则</strong>：该标准定义为接触体积与部件体积之比的最大值，优先考虑具有大面积几何接触的部件分组。</li><li><strong>组大小标准</strong>：作为组件A和B的联合体积在整个形状体积上的占用率。用于控制分组，先小规模取样，然后大规模取样。</li></ol><ul><li><p><strong>部件假设分类和评分</strong>：</p><p>1.训练神经网络对一个部分假设进行分类并为其生成一个置信度分数</p><ol><li>建立具有组件标签的多组件三维模型的训练集；</li><li>设计多尺度CNN（其学习特征表示不仅捕获局部零件几何，而且捕获全局上下文）</li></ol></li><li><p><strong>部件组成推断和标记</strong>：构造一个高阶条件随机场（CRF），以根据前面步骤中的部分假设分析，找到所有组件的最佳标记。</p><p>基于CRF的标记的目的：解决不同部件假设之间的不一致性，并计算一致的部件标记，从而实现所有部件的非重叠分区。</p></li></ul><hr><h2 id="结果和评价部分思路"><a href="#结果和评价部分思路" class="headerlink" title="结果和评价部分思路"></a>结果和评价部分思路</h2><h3 id="多组分标记基准"><a href="#多组分标记基准" class="headerlink" title="多组分标记基准"></a>多组分标记基准</h3><p>构建了第一个带有人为手动注释的组件标签的基准数据集</p><h3 id="标签性能"><a href="#标签性能" class="headerlink" title="标签性能"></a>标签性能</h3><p>根据MCL基准评估我们的语义标记</p><ul><li>基线比较（随机森林）：为每个组件提取特征，并将其输入到随机森林分类器中进行组件分类。</li><li>基线比较（基于CNN的分类）：基于CNN的直接成分分类，没有基于部分假设的分析。以带标签的组件作为训练样本。（标记精度更高，因为部分假设比单个组件捕获更丰富的语义信息。）</li><li>基线比较（基于CNN的假设生成）：通过将Fast RCNN扩展到3D体积表示，实现了基于CNN的假设生成。（组件的显著尺度变化使得体积表示难以表征其形状和结构。证明了我们选择分层搜索来生成零件假设的合理性。）</li><li>最先进方法比较：我们的方法能够处理各种比例和形式的结构，从单个对象到复合场景。</li></ul><h3 id="参数分析和消融研究"><a href="#参数分析和消融研究" class="headerlink" title="参数分析和消融研究"></a>参数分析和消融研究</h3><p><strong>Kc</strong>：为每个成分选择的排名靠前的部分假设数量（一元势中用到）；</p><p><strong>标签性能超过部分假设计数</strong>；</p><p><strong>置信度分数</strong>：该分数衡量它代表独立语义部分的可能性；</p><p>以下略过（总结：我们做的最厉害）</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><strong>研究问题</strong>：基于预先存在的高细粒度组件的现成三维模型的标记分割；</p><p><strong>如何解决</strong>：部分假设分析解决；</p><p><strong>核心思想</strong>：利用零件假设作为三维形状语义成分分析的中间层表示；</p><p><strong>成功的三个关键特征</strong>：</p><ol><li>基于自下而上的方法，以原则性的方式生成部分假设分层分组过程，</li><li>训练一个深层神经网络来编码部分假设，而不是组件，同时考虑局部几何信息和全局上下文信息。</li><li>基于CRF的公式中的高阶势采用了软一致性约束，在最佳标记搜索中提供了更多的自由度。</li></ol><p><strong>未来工作及不足</strong>：将CRF集成到深度神经网络中，以使整个模型端到端可训练，同时避免依赖强大的监督</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Vision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>姿态角与四元数</title>
      <link href="/post/position.html"/>
      <url>/post/position.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="姿态相关"><a href="#姿态相关" class="headerlink" title="姿态相关"></a>姿态相关</h1><h2 id="姿态角"><a href="#姿态角" class="headerlink" title="姿态角"></a>姿态角</h2><p>通常说的飞行器姿态角是指机体坐标系与地面惯性坐标系之间的夹角，可用横滚角-roll、俯仰角-pitch、偏航角-yaw三个角表示。</p><p><img src="https://z3.ax1x.com/2021/11/05/IKkjGn.png" alt="飞行器姿态"></p><p>其中横滚角ϕ、俯仰角θ、偏航角ψ</p><h2 id="四元数（-Quaternion-）"><a href="#四元数（-Quaternion-）" class="headerlink" title="四元数（\Quaternion**）"></a>四元数（<strong><em>\</em>Quaternion**</strong>）</h2><h3 id="定义相关"><a href="#定义相关" class="headerlink" title="定义相关"></a>定义相关</h3><p>四元数是四维超复数。由一个实数单位加上三个虚数单位 。其中实数部分为四元数中的标量部分，虚数部分为四元数的矢量部分。一般定义：</p><script type="math/tex; mode=display">q=w+xi+yj+zk</script><p>其中 w,x,y,z是实数。而i，j，k为虚数。</p><p>四元数也可以表示为q=[w,v],其中v=(x,y,z)是矢量，v虽然是矢量，但不能简单的理解为3D空间的矢量，它是4维空间中的的矢量通俗的讲，一个四元数（Quaternion）描述了一个旋转轴和一个旋转角度。这个旋转轴和这个角度可以通过Quaternion::ToAngleAxis转换得到。当然也可以随意指定一个角度一个旋转轴来构造一个Quaternion。这个角度是相对于单位四元数而言的，也可以说是相对于物体的初始方向而言的。当用一个四元数乘以一个向量时，实际上就是让该向量围绕着这个四元数所描述的旋转轴，转动这个四元数所描述的角度而得到的向量。</p><p>归一化的四元数可以用于表示三维空间中刚体或坐标系的旋转。</p><p>四元数可以表示刚体姿态，这里的姿态是指载体坐标系相对于地理坐标系的旋转。</p><h3 id="四元数表示角度"><a href="#四元数表示角度" class="headerlink" title="四元数表示角度"></a>四元数表示角度</h3><p>四元素感觉上就是轴角的进化，也是使用一个3维向量表示转轴和一个角度分量表示绕此转轴的旋转角度，即(x,y,z,w)。绕坐标轴的多次旋转可以等效为绕某一转轴旋转一定的角度。假设等效旋转轴方向向量为</p><script type="math/tex; mode=display">\vec{K}=\left[k_{x}, k_{y}, k_{z}\right]^{T}</script><p> 等效旋转角为θ，则四元数q=(x,y,z,w)有：</p><script type="math/tex; mode=display">x=k_{x} \cdot \sin \frac{\theta}{2}</script><script type="math/tex; mode=display">y=k_{y} \cdot \sin \frac{\theta}{2}</script><script type="math/tex; mode=display">z=k_{z} \cdot \sin \frac{\theta}{2}</script><script type="math/tex; mode=display">w=\cos \frac{\theta}{2}</script><p>且有</p><script type="math/tex; mode=display">x^{2}+y^{2}+z^{2}+w^{2}=1</script><p>即四元数存储了旋转轴和旋转角的信息，它能方便的描述刚体绕任意轴的旋转。</p><p>四元数的优点有：</p><ul><li>四元数不会有欧拉角存在的 gimbal lock 问题</li><li>四元数由4个数组成，旋转矩阵需要9个数</li><li>两个四元数之间更容易插值</li><li>四元数、矩阵在多次运算后会积攒误差，需要分别对其做规范化(normalize)和正交化(orthogonalize)，对四元数规范化更容易</li><li>与旋转矩阵类似，两个四元组相乘可表示两次旋转</li></ul><h2 id="四元数的各种转换"><a href="#四元数的各种转换" class="headerlink" title="四元数的各种转换"></a>四元数的各种转换</h2><h3 id="四元数转欧拉角"><a href="#四元数转欧拉角" class="headerlink" title="四元数转欧拉角"></a>四元数转欧拉角</h3><script type="math/tex; mode=display">\left[\begin{array}{c}\varphi \\ \theta \\ \psi\end{array}\right]=\left[\begin{array}{c}\operatorname{atan} 2\left(2(w x+y z), 1-2\left(x^{2}+y^{2}\right)\right) \\ \arcsin (2(w y-z x)) \\ \operatorname{atan} 2\left(2(w z+x y), 1-2\left(y^{2}+z^{2}\right)\right)\end{array}\right]</script><p>也可以通过代码转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;tf/transform_datatypes.h&quot;//转换函数头文件</span><br><span class="line">#include &lt;nav_msgs/Odometry.h&gt;//里程计信息格式</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/****************四元数转RPY欧拉角，以odomsub的回调函数为例*****************/</span><br><span class="line"> </span><br><span class="line">void odomCallback(const nav_msgs::Odometry &amp;odom) &#123;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">      tf::Quaternion quat;</span><br><span class="line">      tf::quaternionMsgToTF(odom.pose.pose.orientation, quat);</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">      double roll, pitch, yaw;//定义存储r\p\y的容器</span><br><span class="line">      tf::Matrix3x3(quat).getRPY(roll, pitch, yaw);//进行转换</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/****************RPY欧拉角转四元数*****************/</span><br><span class="line">tf::createQuaternionMsgFromRollPitchYaw(double r, double p, double y);//返回四元数</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">tf::createQuaternionMsgFromYaw(double y);//只通过y即绕z的旋转角度计算四元数，用于平面小车。返回四元数</span><br></pre></td></tr></table></figure><h3 id="欧拉角转四元数"><a href="#欧拉角转四元数" class="headerlink" title="欧拉角转四元数"></a>欧拉角转四元数</h3><script type="math/tex; mode=display">q=\left[\begin{array}{l}w \\ x \\ y \\ z\end{array}\right]=\left[\begin{array}{l}\cos (\varphi / 2) \cos (\theta / 2) \cos (\psi / 2)+\sin (\varphi / 2) \sin (\theta / 2) \sin (\psi / 2) \\ \sin (\varphi / 2) \cos (\theta / 2) \cos (\psi / 2)-\cos (\varphi / 2) \sin (\theta / 2) \sin (\psi / 2) \\ \cos (\varphi / 2) \sin (\theta / 2) \cos (\psi / 2)+\sin (\varphi / 2) \cos (\theta / 2) \sin (\psi / 2) \\ \cos (\varphi / 2) \cos (\theta / 2) \sin (\psi / 2)-\sin (\varphi / 2) \sin (\theta / 2) \cos (\psi / 2)\end{array}\right]</script><h2 id="九轴姿态融合"><a href="#九轴姿态融合" class="headerlink" title="九轴姿态融合"></a>九轴姿态融合</h2><h3 id="陀螺仪（gyroscope）"><a href="#陀螺仪（gyroscope）" class="headerlink" title="陀螺仪（gyroscope）"></a>陀螺仪（gyroscope）</h3><p>陀螺仪测量的是角速度，即物体转动的速度，把速度和时间相乘，即可以得到某一时间段内物体转过的角度。对于陀螺仪的角速度测量，比较好理解，简单来说，相当于一个人绕着一个圆圈行走，假如他的速度是1度没秒，那么通过速度乘以时间，我们就可以知道他距离起点走了多少度。</p><h3 id="加速度计（accelerometer）"><a href="#加速度计（accelerometer）" class="headerlink" title="加速度计（accelerometer）"></a>加速度计（accelerometer）</h3><p>加速度计测量的是物体的加速度，重力加速度是一个物体受重力作用的情况下所具有的加速度。当物体处于静止状态时，加速度计测量出来的值就等于重力加速度1g, 约等于9.8米每平方秒。重力加速度g的方向总是竖直向下的，通过获得重力加速度在其X轴，Y轴上的分量，我们可以计算出物体相对于水平面的倾斜角度。</p><p>一个简单的例子如下: 一个单轴的加速计位于重力水平面上的时候，它在垂直方向上受到的加速度为1g，在水平方向上受到的加速度为0。当我们把它旋转一个角度的时候，就会在水平轴上产生一个加速度分量。通过它们的关系，就可以计算出该单轴加速计的倾角。</p><p><img src="https://img-blog.csdnimg.cn/20200926113232528.png" alt="img"></p><p>在一个三轴的加速度传感器中，可以通过下列的反正切函数运算公式来计算加速度计各个轴的倾角</p><p><img src="https://z3.ax1x.com/2021/11/05/IKA8JA.png" alt="img"></p><p>故此，陀螺仪测量yaw；加速度计测量roll，pitch。</p><p>MPU6050和MPU9150的传感器方向定义,其中MPU6050只包含陀螺仪和加速计共六个轴，而MPU9150还包含磁力计，共九个轴。</p><p><img src="https://z3.ax1x.com/2021/11/05/IKAGRI.png" alt="img"></p><h1 id="Manhony"><a href="#Manhony" class="headerlink" title="Manhony"></a>Manhony</h1><div class="mermaid">flowchart LR    上一时刻姿态+陀螺仪数据 --&gt; 下一时刻姿态的预测量    下一时刻姿态的预测量 --&gt; 下一时刻重力、磁场方向    下一时刻重力、磁场方向 --&gt; 与磁力计、加速度计的值叉乘得到误差    与磁力计、加速度计的值叉乘得到误差 --&gt; P、I调节器    P、I调节器 --&gt; 修正陀螺仪数据    修正陀螺仪数据 --&gt; 更新姿态</div><div class="mermaid">flowchart LR高阶CRF--&gt;推断所有组件的最佳标记分配</div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/Nirvana_Tai/article/details/105554473?spm=1001.2101.3001.6650.9&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9.pc_relevant_default&amp;utm_relevant_index=12">https://blog.csdn.net/Nirvana_Tai/article/details/105554473</a></p><p><a href="https://blog.csdn.net/RoboChengzi/article/details/97616482">https://blog.csdn.net/RoboChengzi/article/details/97616482</a></p>]]></content>
      
      
      <categories>
          
          <category> 硬件相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quaternion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 基础 + 数据可视化</title>
      <link href="/post/python.html"/>
      <url>/post/python.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><div class="note blue flat"><p>记录 python 爬虫的一些知识点 - Forever Settle</p></div><h1 id="爬取豆瓣-Top250-电影信息"><a href="#爬取豆瓣-Top250-电影信息" class="headerlink" title="爬取豆瓣 Top250 电影信息"></a>爬取豆瓣 Top250 电影信息</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup     #网页解析，获取数据</span><br><span class="line">import re       #正则表达式，进行文字匹配</span><br><span class="line">import urllib.request,urllib.error      #制定URL，获取网页数据</span><br><span class="line">import xlwt     #进行excel操作</span><br><span class="line">import sqlite3  #进行SQLite数据库操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    baseurl = &quot;https://movie.douban.com/top250?start=&quot;</span><br><span class="line">    #1.爬取网页</span><br><span class="line">    datalist = getData(baseurl)</span><br><span class="line">    #savepath = &quot;豆瓣电影Top250.xls&quot;</span><br><span class="line">    dbpath = &quot;movie.db&quot;</span><br><span class="line">    #3.保存数据</span><br><span class="line">    #saveData(datalist,savepath)</span><br><span class="line">    saveData2DB(datalist,dbpath)</span><br><span class="line"></span><br><span class="line">    #askURL(&quot;https://movie.douban.com/top250?start=&quot;)</span><br><span class="line"></span><br><span class="line">#影片详情链接的规则</span><br><span class="line">findLink = re.compile(r&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&#x27;)     #创建正则表达式对象，表示规则（字符串的模式）</span><br><span class="line">#影片图片</span><br><span class="line">findImgSrc = re.compile(r&#x27;&lt;img.*src=&quot;(.*?)&quot;&#x27;,re.S)   #re.S 让换行符包含在字符中</span><br><span class="line">#影片片名</span><br><span class="line">findTitle = re.compile(r&#x27;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&#x27;)</span><br><span class="line">#影片评分</span><br><span class="line">findRating = re.compile(r&#x27;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*)&lt;/span&gt;&#x27;)</span><br><span class="line">#找到评价人数</span><br><span class="line">findJudge = re.compile(r&#x27;&lt;span&gt;(\d*)人评价&lt;/span&gt;&#x27;)</span><br><span class="line">#找到概况</span><br><span class="line">findInq = re.compile(r&#x27;&lt;span class=&quot;inq&quot;&gt;(.*)&lt;/span&gt;&#x27;)</span><br><span class="line">#找到影片的相关内容</span><br><span class="line">findBd = re.compile(r&#x27;&lt;p class=&quot;&quot;&gt;(.*?)&lt;/p&gt;&#x27;,re.S)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#爬取网页</span><br><span class="line">def getData(baseurl):</span><br><span class="line">    datalist = []</span><br><span class="line">    for i in range(0,10):       #调用获取页面信息的函数，10次</span><br><span class="line">        url = baseurl</span><br><span class="line">        html = askURL(url)      #保存获取到的网页源码</span><br><span class="line"></span><br><span class="line">        # 2.逐一解析数据</span><br><span class="line">        soup = BeautifulSoup(html,&quot;html.parser&quot;)</span><br><span class="line">        for item in soup.find_all(&#x27;div&#x27;,class_=&quot;item&quot;):     #查找符合要求的字符串，形成列表</span><br><span class="line">            #print(item)   #测试：查看电影item全部信息</span><br><span class="line">            data = []    #保存一部电影的所有信息</span><br><span class="line">            item = str(item)</span><br><span class="line"></span><br><span class="line">            #影片详情的链接</span><br><span class="line">            link = re.findall(findLink,item)[0]     #re库用来通过正则表达式查找指定的字符串</span><br><span class="line">            data.append(link)                       #添加链接</span><br><span class="line"></span><br><span class="line">            imgSrc = re.findall(findImgSrc,item)[0]</span><br><span class="line">            data.append(imgSrc)                     #添加图片</span><br><span class="line"></span><br><span class="line">            titles = re.findall(findTitle,item)     #片名可能只有一个中文名，没有外国名</span><br><span class="line">            if(len(titles) == 2):</span><br><span class="line">                ctitle = titles[0]                  #添加中文名</span><br><span class="line">                data.append(ctitle)</span><br><span class="line">                otitle = titles[1].replace(&quot;/&quot;,&quot;&quot;)  #去掉无关的符号</span><br><span class="line">                data.append(otitle)                 #添加外国名</span><br><span class="line">            else:</span><br><span class="line">                data.append(titles[0])</span><br><span class="line">                data.append(&#x27; &#x27;)        #外国名字留空</span><br><span class="line"></span><br><span class="line">            rating = re.findall(findRating,item)[0]</span><br><span class="line">            data.append(rating)                        #添加评分</span><br><span class="line"></span><br><span class="line">            judgeNum = re.findall(findJudge,item)[0]</span><br><span class="line">            data.append(judgeNum)                       #提加评价人数</span><br><span class="line"></span><br><span class="line">            inq = re.findall(findInq,item)</span><br><span class="line">            if len(inq) != 0:</span><br><span class="line">                inq = inq[0].replace(&quot;。&quot;,&quot;&quot;)    #去掉句号</span><br><span class="line">                data.append(inq)                # 添加概述</span><br><span class="line">            else:</span><br><span class="line">                data.append(&quot; &quot;)                #留空</span><br><span class="line"></span><br><span class="line">            bd = re.findall(findBd,item)[0]</span><br><span class="line">            bd = re.sub(&#x27;&lt;br(\s+)?/&gt;(\s+)?&#x27;,&quot; &quot;,bd)   #去掉&lt;br/&gt;</span><br><span class="line">            bd = re.sub(&#x27;/&#x27;,&quot; &quot;,bd)     #替换/</span><br><span class="line">            data.append(bd.strip())     #去掉前后的空格</span><br><span class="line"></span><br><span class="line">            datalist.append(data)       #把处理好的一部电影信息放入datalist</span><br><span class="line">            #print(datalist)</span><br><span class="line">    return datalist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#得到指定一个URL的网页内容</span><br><span class="line">def askURL(url):</span><br><span class="line">    head = &#123;                #模拟浏览器头部信息，向豆瓣服务器发送消息</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    #用户代理，表示告诉豆瓣服务器，我们是什么类型的机器、浏览器（本质上是告诉浏览器，我们可以接收什么水平的文件内容）</span><br><span class="line"></span><br><span class="line">    request = urllib.request.Request(url,headers=head) #发起一个请求把head传进去</span><br><span class="line">    html = &quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        response = urllib.request.urlopen(request)</span><br><span class="line">        html = response.read().decode(&quot;utf-8&quot;) #解析</span><br><span class="line">        #print(html)</span><br><span class="line">    except urllib.error.URLError as e:</span><br><span class="line">        if hasattr(e,&quot;code&quot;):</span><br><span class="line">            print(e.code)</span><br><span class="line">        if hasattr(e,&quot;reason&quot;):</span><br><span class="line">            print(e.reason)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">#保存数据</span><br><span class="line">def saveData(datalist,savepath):</span><br><span class="line">    print(&quot;save....&quot;)</span><br><span class="line">    book = xlwt.Workbook(encoding=&quot;utf-8&quot;,style_compression=0)  #创建workbook对象</span><br><span class="line">    sheet = book.add_sheet(&#x27;豆瓣电影Top250&#x27;,cell_overwrite_ok=True)    #创建工作表</span><br><span class="line">    col = (&quot;电影详情链接&quot;,&quot;图片链接&quot;,&quot;影片中文名&quot;,&quot;影片外国名&quot;,&quot;评分&quot;,&quot;评价数&quot;,&quot;概况&quot;,&quot;相关信息&quot;)</span><br><span class="line">    for i in range(0,8):</span><br><span class="line">        sheet.write(0,i,col[i]) #列名</span><br><span class="line">    for i in range(0,250):</span><br><span class="line">        print(&quot;第%d条&quot; %(i+1))</span><br><span class="line">        data = datalist[i]</span><br><span class="line">        for j in range(0,8):</span><br><span class="line">            sheet.write(i+1,j,data[j])      #数据</span><br><span class="line"></span><br><span class="line">    book.save(savepath)       #保存</span><br><span class="line"></span><br><span class="line">def saveData2DB(datalist,dbpath):</span><br><span class="line">    init_db(dbpath)</span><br><span class="line">    conn=sqlite3.connect(dbpath)</span><br><span class="line">    cur=conn.cursor()</span><br><span class="line">    for data in datalist:</span><br><span class="line">        for index in range(len(data)):</span><br><span class="line">            if index ==4 or index==5:</span><br><span class="line">                continue</span><br><span class="line">            data[index]=&#x27;&quot;&#x27;+data[index]+&#x27;&quot;&#x27;</span><br><span class="line">        sql=&#x27;&#x27;&#x27;insert into movie250 (</span><br><span class="line">                   info_link,pic_link,cname,ename,score,rated,introduction,info)</span><br><span class="line">                   values(%s)&#x27;&#x27;&#x27;%&quot;,&quot;.join(data)</span><br><span class="line">        print(sql)</span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        conn.commit()</span><br><span class="line">    cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def init_db(dbpath):</span><br><span class="line">    sql=&#x27;&#x27;&#x27;</span><br><span class="line">        create table movie250</span><br><span class="line">        (</span><br><span class="line">        id integer primary key autoincrement,</span><br><span class="line">        info_link text,</span><br><span class="line">        pic_link text,</span><br><span class="line">        cname varchar ,</span><br><span class="line">        ename varchar ,</span><br><span class="line">        score numeric,</span><br><span class="line">        rated numeric,</span><br><span class="line">        introduction text,</span><br><span class="line">        info text </span><br><span class="line">        )</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    conn=sqlite3.connect(dbpath)</span><br><span class="line">    cursor=conn.cursor()</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    conn.commit()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:          #当程序执行时</span><br><span class="line">    #调用函数</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line">    #init_db(&quot;movietest.db&quot;)</span><br><span class="line">    print(&quot;爬取完毕！&quot;)</span><br></pre></td></tr></table></figure><h1 id="爬取西南计院录取信息"><a href="#爬取西南计院录取信息" class="headerlink" title="爬取西南计院录取信息"></a>爬取西南计院录取信息</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#得到指定一个url网页内容</span><br><span class="line">import re</span><br><span class="line">import urllib.request</span><br><span class="line">import xlwt</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def askURL(url):</span><br><span class="line">    header = &#123;</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    # 用户代理告诉浏览器我们可以接受什么水平的文本</span><br><span class="line">    request = urllib.request.Request(url, headers=header)</span><br><span class="line">    html = &quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        response = urllib.request.urlopen(request)</span><br><span class="line">        html = response.read().decode(&quot;utf-8&quot;)</span><br><span class="line">        #print(html)</span><br><span class="line">    except urllib.error.URLError as e:</span><br><span class="line">        if hasattr(e, &quot;code&quot;):</span><br><span class="line">            print(e.code)</span><br><span class="line">        if hasattr(e, &quot;reason&quot;):</span><br><span class="line">            print(e.reason)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">#爬取网页</span><br><span class="line">def getData(baseurl):</span><br><span class="line">    datalist=[]</span><br><span class="line">    for i in range(0,1):#调用获取页面信息的函数10次</span><br><span class="line">       url=baseurl</span><br><span class="line">       html=askURL(url)#保存获取道德网页</span><br><span class="line">       # 逐一解析数据</span><br><span class="line">       soup=BeautifulSoup(html,&quot;html.parser&quot;)</span><br><span class="line">       for item in soup.find_all(&#x27;tr&#x27;,style=&quot;height: 17px;&quot;):</span><br><span class="line">          #print(item)#查看电影item全部信息</span><br><span class="line">          data=[]#保存一部电影的全部信息</span><br><span class="line">          item=str(item)</span><br><span class="line">          Num1=re.findall(findNum,item)[0]</span><br><span class="line">          data.append(Num1)</span><br><span class="line"></span><br><span class="line">          Name=re.findall(findName,item)[0]</span><br><span class="line">          data.append(Name)</span><br><span class="line"></span><br><span class="line">          Num2=re.findall(findNum,item)[1]</span><br><span class="line">          data.append(Num2)</span><br><span class="line">          Num3=re.findall(findNum,item)[2]</span><br><span class="line">          data.append(Num3)</span><br><span class="line">          Num4=re.findall(findNum,item)[3]</span><br><span class="line">          data.append(Num4)</span><br><span class="line">          Num5=re.findall(findNum,item)[4]</span><br><span class="line">          data.append(Num5)</span><br><span class="line">          Num6=re.findall(findNum,item)[5]</span><br><span class="line">          data.append(Num6)</span><br><span class="line">          Ru=re.findall(findName,item)[1]</span><br><span class="line">          data.append(Ru)</span><br><span class="line">          datalist.append(data) #把处理好的一部电影信息放入datalist</span><br><span class="line">          #print(datalist) #查找符合要求的字符串形成列表</span><br><span class="line">    return datalist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def saveData(datalist,savepath):</span><br><span class="line">    print(&quot;save....&quot;)</span><br><span class="line">    book=xlwt.Workbook(encoding=&quot;utf-8&quot;,style_compression=0) #创建workbook对象</span><br><span class="line">    sheet=book.add_sheet(&#x27;2021西南大学计算机学院复试名单&#x27;,cell_overwrite_ok=True) #创建工作表</span><br><span class="line">    col=(&#x27;考生编号&#x27;,&quot;姓名&quot;,&quot;政治成绩&quot;,&quot;外国语成绩&quot;,&quot;业务课一成绩&quot;,&quot;业务课二成绩&quot;,&quot;初试总成绩&quot;,&quot;备注&quot;) #写入数据 第一个参数”行“，第二个参数”列“，第三个参数内容</span><br><span class="line">    for i in range(0,8):</span><br><span class="line">        sheet.write(0,i,col[i])#列名</span><br><span class="line">    for i in range(0,197):</span><br><span class="line">        print(&quot;第%d条&quot; %(i+1))</span><br><span class="line">        data=datalist[i]</span><br><span class="line">        for j in range(0,8):</span><br><span class="line">            sheet.write(i+1,j,data[j])#数据</span><br><span class="line">    book.save(savepath)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    baseurl=&quot;http://cis.swu.edu.cn/s/cis/zsjy/20210325/4413251.html&quot;</span><br><span class="line">    #1爬取网页</span><br><span class="line">    datalist=getData(baseurl)</span><br><span class="line">    savepath=&quot;2021西南大学计算机学院复试名单.xls&quot;</span><br><span class="line">    #3保存数据</span><br><span class="line">    saveData(datalist,savepath)</span><br><span class="line"></span><br><span class="line">    #askURL(baseurl)</span><br><span class="line"></span><br><span class="line">#数字相关包括分数和考生编号</span><br><span class="line">findNum=re.compile(r&#x27;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;(\d*)&lt;/span&gt;&#x27;)</span><br><span class="line">#姓名及备注 文字信息</span><br><span class="line">findName=re.compile(r&#x27;&lt;span style=&quot;font-family: 宋体;&quot;&gt;(.*?)&lt;/span&gt;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    #调用函数</span><br><span class="line">    main()</span><br><span class="line">    print(&quot;爬取完毕&quot;)</span><br></pre></td></tr></table></figure><h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p>主要借助 Flask 框架、Echarts、WordCloud 等技术实现</p><h2 id="模板网站"><a href="#模板网站" class="headerlink" title="模板网站"></a>模板网站</h2><p><a href="http://www.cssmoban.com/"></a></p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><img src="https://z3.ax1x.com/2021/05/22/gLMtN4.png" alt=""></p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p>app.py<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask,render_template</span><br><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&quot;index.html&quot;)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/index&#x27;)</span><br><span class="line">def home():</span><br><span class="line">    return index()</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/movie&#x27;)</span><br><span class="line">def movie():</span><br><span class="line">    datalist=[]</span><br><span class="line">    con=sqlite3.connect(&quot;movie.db&quot;)</span><br><span class="line">    cur=con.cursor()</span><br><span class="line">    sql=&quot;select * from movie250&quot;</span><br><span class="line">    data=cur.execute(sql)</span><br><span class="line">    for item in data:</span><br><span class="line">        datalist.append(item)</span><br><span class="line">    cur.close()</span><br><span class="line">    con.close()</span><br><span class="line">    return render_template(&quot;movie.html&quot;,movies=datalist)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/score&#x27;)</span><br><span class="line">def score():</span><br><span class="line">     score=[] #评分</span><br><span class="line">     num=[] #评分人数</span><br><span class="line">     con=sqlite3.connect(&quot;movie.db&quot;)</span><br><span class="line">     cur=con.cursor()</span><br><span class="line">     sql=&quot;select score,count(score) from movie250 group by score&quot;</span><br><span class="line">     data=cur.execute(sql)</span><br><span class="line">     for item in data:</span><br><span class="line">        score.append(item[0])</span><br><span class="line">        num.append(item[1])</span><br><span class="line">     cur.close()</span><br><span class="line">     con.close()</span><br><span class="line">     return render_template(&quot;score.html&quot;,score=score,num=num)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/team&#x27;)</span><br><span class="line">def team():</span><br><span class="line">    return render_template(&quot;team.html&quot;)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/word&#x27;)</span><br><span class="line">def word():</span><br><span class="line">    return render_template(&quot;word.html&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><br>testCloud.py<br>// 利用 wordcloud 生成词云，这里用了树形遮罩图片<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import jieba#分词</span><br><span class="line">from matplotlib import pyplot as plt #绘图数据可视化</span><br><span class="line">from wordcloud import WordCloud #词云</span><br><span class="line">from PIL import Image #图片处理</span><br><span class="line">import numpy as np #矩阵运算</span><br><span class="line">import sqlite3 #数据库</span><br><span class="line"></span><br><span class="line">#准备词云所需的文字或者词</span><br><span class="line">con=sqlite3.connect(&#x27;movie.db&#x27;)</span><br><span class="line">cur=con.cursor()</span><br><span class="line">sql=&#x27;select introduction from movie250&#x27;</span><br><span class="line">data=cur.execute(sql)</span><br><span class="line">text=&quot;&quot;</span><br><span class="line">for item in data:</span><br><span class="line">    text=text+item[0]</span><br><span class="line">#print(text)</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br><span class="line"></span><br><span class="line">#分词</span><br><span class="line">cut=jieba.cut(text)</span><br><span class="line">string=&#x27; &#x27;.join(cut)</span><br><span class="line">#print(string)</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">img=Image.open(r&#x27;.\static\assets\img\tree.jpg&#x27;) #打开遮罩图片</span><br><span class="line">img_array=np.array(img) #将图片转换为数组</span><br><span class="line">wc=WordCloud(</span><br><span class="line">    background_color=&#x27;white&#x27;,</span><br><span class="line">    mask=img_array,</span><br><span class="line">    font_path=&quot;msyhl.ttc&quot;</span><br><span class="line">)</span><br><span class="line">wc.generate_from_text(string)</span><br><span class="line"></span><br><span class="line">#绘制图片</span><br><span class="line">fig =plt.figure(1)</span><br><span class="line">plt.imshow(wc)</span><br><span class="line">plt.axis(&#x27;off&#x27;)#是否显示坐标轴</span><br><span class="line"></span><br><span class="line"># plt.show()#显示生成的词云图片</span><br><span class="line"></span><br><span class="line">plt.savefig(r&#x27;.\static\assets\img\word.jpg&#x27;,dpi=500)</span><br></pre></td></tr></table></figure><br>需要爬取得到的 movie.db 作为数据源<br><img src="https://z3.ax1x.com/2021/05/22/gLMDu6.png" alt=""></p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://z3.ax1x.com/2021/05/22/gLM7VS.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/22/gL1d3j.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/22/gL1hvR.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/22/gL3UZ6.png" alt=""></p><h1 id="异步加载网页爬取"><a href="#异步加载网页爬取" class="headerlink" title="异步加载网页爬取"></a>异步加载网页爬取</h1><p>异步加载通常指一些需要加载更多的网页如 b 站评论、NHK 新闻或者当前网页无法爬取，多是通过 json 进行爬取<br>首先网址不应是当前页面地址而应该是 json 地址<br>这里选择爬取 51job 网站</p><h1 id="几个需要注意的点"><a href="#几个需要注意的点" class="headerlink" title="几个需要注意的点"></a>几个需要注意的点</h1><ol><li>间隔时间爬取</li><li>用代理</li></ol>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python 深度学习》笔记</title>
      <link href="/post/machine-learning.html"/>
      <url>/post/machine-learning.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><div class="note blue flat"><p>记录机器学习的一些知识点 - Forever Settle</p></div><h1 id="第一章-什么是深度学习"><a href="#第一章-什么是深度学习" class="headerlink" title="第一章 什么是深度学习"></a>第一章 什么是深度学习</h1><h2 id="人工智能、机器学习与深度学习"><a href="#人工智能、机器学习与深度学习" class="headerlink" title="人工智能、机器学习与深度学习"></a>人工智能、机器学习与深度学习</h2><p><img src="https://www.hualigs.cn/image/609fe5bc31dba.jpg" alt="三者之间的关系"></p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>简洁的定义：努力将通常由人类完成的智力任务自动化。</p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>虽然符号主义人工智能适合用来解决定义明确的逻辑问题，但它难以给出明确的规则来解决更加复杂、模糊的问题，比如图像分类、语音识别和语言翻译。于是出现了一种新的方法来替代符号主义人工智能，这就是机器学习（machine learning）。<br>机器学习：一种新的编程范式<br>机器学习系统是训练出来的，而不是明确地用程序编写出来的。将与某个任务相关的许多示例输入机器学习系统，它会在这些示例中找到统计结构， 从而最终找到规则将任务自动化。举个例子，你想为度假照片添加标签，并且希望将这项任务自动化，那么你可以将许多人工打好标签的照片输入机器学习系统，系统将学会将照片与特定标签联系在一起的统计规则。</p><h3 id="从数据中学习表示"><a href="#从数据中学习表示" class="headerlink" title="从数据中学习表示"></a>从数据中学习表示</h3><p>我们需要一下三个要素来进行机器学习：</p><p>①. 输入数据点。例如，你的任务是语音识别，那么这些数据点可能是记录人们说话的声音文件。如果你的任务是为图像添加标签，那么这些数据点可能是图像。<br>②. 预期输出的示例。对于语音识别任务来说，这些示例可能是人们根据声音文件整理生成的文本。对于图像标记任务来说，预期输出可能是 “狗”“猫” 之类的标签。<br>③. 衡量算法效果好坏的方法。这一衡量方法是为了计算算法的当前输出与预期输出的差距。衡量结果是一种反馈信号，用于调节算法的工作方式。这个调节步骤就是我们所说的学习。</p><p>机器学习模型将输入数据变换为有意义的输出，这是一个从已知的输入和输出示例中进行 “学习” 的过程。机器学习中的学习指的是，寻找更好数据表示的自动搜索过程。</p><p>机器学习的技术定义：在预先定义好的可能性空间中，利用反馈信号的指引来寻找输入数据的有用表示。</p><h3 id="深度学习之”-深度”"><a href="#深度学习之”-深度”" class="headerlink" title="深度学习之” 深度”"></a>深度学习之” 深度”</h3><p>深度学习强调从连续的层（layer）中进行学习，这些层对应于越来越有意义的表示。“深度学习” 中的 “深度” 指的是一系列连续的表示层。数据模型中包含多少层，这被称为模型的 “深度（depth）”。</p><p>用于数字分类的深度神经网络</p><p>数字图像分类模型学到的深度表示</p><p>这个网络将数字图像转换成与原始图像差别越来越大的表示，而其中关于最终结果的信息却越来越丰富。可以将深度网络看做多级信息蒸馏操作：信息穿过连续的过滤器，其纯度越来越高（即对任务的帮助越来越大）。</p><p>深度学习的技术定义：学习数据表示的多级方法。</p><h3 id="深度学习的工作原理"><a href="#深度学习的工作原理" class="headerlink" title="深度学习的工作原理"></a>深度学习的工作原理</h3><p>神经网络中每层对输入数据所做的具体操作保存在该层的权重（weight）中，其本质是一串数字。 用术语来说，每层实现的变换由其权重来参数化（parameterize）。 学习的意思是为神经网络的所有层找到一组权重值，使得该网络能够将每个示例输入与其目标正确地一一对应。</p><p>神经网络是由其权重来参数化</p><p>想要控制神经网络的输出，就需要能够衡量该输出与预期值之间的距离。这是神经网络损失函数（loss function）的任务。</p><p>损失函数用来衡量网络输出结果的质量</p><p>深度学习的基本技巧是利用这个距离值作为反馈信号来对权重值进行微调，以降低当前示例对应的损失值。这种调节由优化器（optimizer）完成， 它实现了所谓的反向传播（backpropagation）算法（下一章介绍），这是深度学习的核心算法。</p><p>将损失值作为反馈信号来调节权重</p><p>一开始对神经网络的权重随机赋值，因此网络只是实现了一系列随机变换。其输出结果自然也和理想值相去甚远，相应地，损失值也很高。但随着网络处理的示例越来越多，权重值也在向正确的方向逐步微调，损失值也逐渐降低。这就是训练循环（training loop）。</p><h1 id="第二章-神经网络的数学基础"><a href="#第二章-神经网络的数学基础" class="headerlink" title="第二章 神经网络的数学基础"></a>第二章 神经网络的数学基础</h1><h2 id="神经网络的数据表示"><a href="#神经网络的数据表示" class="headerlink" title="神经网络的数据表示"></a>神经网络的数据表示</h2><p>当前所有机器学习系统都使用张量作为基本数据结构。<br>张量是一个数据容器，包含的数据几乎总是数值数据，是矩阵向任意维度的推广。张量的维度通常叫做轴</p><h3 id="标量（0D-张量）"><a href="#标量（0D-张量）" class="headerlink" title="标量（0D 张量）"></a>标量（0D 张量）</h3><p>仅包含一个数字的张量叫做标量（scalar）或 0 维张量，有 0 个轴。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; x = np.array(12)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">array(12)</span><br><span class="line">&gt;&gt;&gt; x.ndim</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><h3 id="向量（1D-张量）"><a href="#向量（1D-张量）" class="headerlink" title="向量（1D 张量）"></a>向量（1D 张量）</h3><p>数字组成的数组叫做向量（vector）或一维张量（1D 张量），有 1 个轴。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.array([12, 3, 6, 14, 7])</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">array([12, 3, 6, 14, 7])</span><br><span class="line">&gt;&gt;&gt; x.ndim</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><h3 id="矩阵（2D-张量）"><a href="#矩阵（2D-张量）" class="headerlink" title="矩阵（2D 张量）"></a>矩阵（2D 张量）</h3><p>向量组成的数组叫做矩阵（matrix）或二维张量（2D 张量）。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.array([[5, 78, 2, 34, 0],</span><br><span class="line">[6, 79, 3, 35, 1],</span><br><span class="line">[7, 80, 4, 36, 2]])</span><br><span class="line">&gt;&gt;&gt; x.ndim</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><h3 id="3D-张量与更高维张量"><a href="#3D-张量与更高维张量" class="headerlink" title="3D 张量与更高维张量"></a>3D 张量与更高维张量</h3><p>将多个矩阵组合成一个新的数组，可以得到一个 3D 张量。 将多个 3D 张量组合成一个数组，可以创建一个 4D 张量。</p><p>深度学习处理的一般都是 0D 到 4D 的张量，但处理视频数据时可能会遇到 5D 张量</p><h3 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h3><p>张量是由一下三个关键属性来定义的：</p><p>轴的个数（阶，ndim）。3D 张量有 3 个轴，矩阵有 2 个轴。<br>形状（shape）。是一个整数元组，表示张量沿每个轴的维度大小（元素个数）。矩阵示例形状：{3,5}；3D 张量示例形状：{3,3,5}。<br>数据类型（dtype）：可以是 float32、uint8、float64 等。</p><h3 id="在-Numpy-中操作张量"><a href="#在-Numpy-中操作张量" class="headerlink" title="在 Numpy 中操作张量"></a>在 Numpy 中操作张量</h3><p>选择张量的特定元素叫做张量切片（tensor slicing）。</p><p>例子：选择 10-100 个数字（不包括 100），并将其放在形状为（90,28,28）的数组中。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_slice = train_images[10:100]</span><br><span class="line">&gt;&gt;&gt; print(my_slice.shape)</span><br><span class="line">(90, 28, 28)</span><br><span class="line"># 等同于：</span><br><span class="line">&gt;&gt;&gt; my_slice = train_images[10:100, :, :]</span><br><span class="line">&gt;&gt;&gt; my_slice.shape</span><br><span class="line">(90, 28, 28)</span><br><span class="line">&gt;&gt;&gt; my_slice = train_images[10:100, 0:28, 0:28]</span><br><span class="line">&gt;&gt;&gt; my_slice.shape</span><br><span class="line">(90, 28, 28)</span><br></pre></td></tr></table></figure></p><h3 id="数据批量的概念"><a href="#数据批量的概念" class="headerlink" title="数据批量的概念"></a>数据批量的概念</h3><p>深度学习中数据张量的第一个轴（0 轴）都是样本轴（samples axis，样本维度）。</p><p>深度学习模型不会同时处理整个数据集，而是将数据拆分成小批量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#批量大小为128</span><br><span class="line">batch = train_images&amp;#123;:128&amp;#125;</span><br><span class="line">#然后是下一个批量</span><br><span class="line">batch = train_images&amp;#123;128:256&amp;#125;</span><br><span class="line">#然后是第n个批量</span><br><span class="line">batch = train_images[128 * n:128 * (n + 1)]</span><br></pre></td></tr></table></figure><br>对于这种批量张量。第一个轴（0 轴）叫做批量轴（batch axis） 或 批量维度（batch dimension）。</p><h3 id="现实世界中的数据张量"><a href="#现实世界中的数据张量" class="headerlink" title="现实世界中的数据张量"></a>现实世界中的数据张量</h3><p>现实中要处理的数据几乎总是以下类别之一：</p><p>向量数据：2D 张量，形状为 (samples, features)。</p><p>时间序列数据或序列数据：3D 张量，形状为 (samples, timesteps,features)。</p><p>图像：4D 张量，形状为 (samples, height, width, channels) 或 (samples,channels,height, width)。</p><p>视频：5D 张量，形状为 (samples, frames, height, width, channels) 或 (samples,frames, channels, height, width)。</p><h3 id="向量数据"><a href="#向量数据" class="headerlink" title="向量数据"></a>向量数据</h3><p>每个数据点都被编码为一个向量，因此一个数据批量就被编码为 2D 张量，其中第一个轴是样本轴， 第二个轴是特征轴。</p><h3 id="时间序列数据或序列数据"><a href="#时间序列数据或序列数据" class="headerlink" title="时间序列数据或序列数据"></a>时间序列数据或序列数据</h3><p>每个样本可以被编码为一个向量序列（即 2D 张量），因此一个数据批量就被编码为一个 3D 张量。</p><h3 id="图像数据"><a href="#图像数据" class="headerlink" title="图像数据"></a>图像数据</h3><p>图像通常具有三个维度：高度、宽度和颜色深度。图像张量时钟都是 3D 张量。</p><p>128 张大小为 256×256 的灰度图像组成的批量可以保存在大小为 {128,256,256,1} 张量。</p><p>128 张彩色图像：{128,256,256,3}。</p><p>图像数据组成的 4D 张量<br>图像数据组成的 4D 张量</p><p>TensorFlow 中遵循通道在后的约定，即将颜色深度轴放在最后：{samples,height,width,color_depth}</p><h3 id="视频数据"><a href="#视频数据" class="headerlink" title="视频数据"></a>视频数据</h3><p>保存在 5D 张量中：{samples,frame,height,width,color_depth}</p><h2 id="神经网络的-“齿轮”：张量运算"><a href="#神经网络的-“齿轮”：张量运算" class="headerlink" title="神经网络的 “齿轮”：张量运算"></a>神经网络的 “齿轮”：张量运算</h2><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>将两个形状不同的张量相加，较小的张量会被广播（broadcast），以匹配较大张量的形状。</p><p>步骤：</p><p>①. 向较小的张量添加轴（叫作广播轴），使其 ndim 与较大的张量相同。<br>②. 将较小的张量沿着新轴重复，使其形状与较大的张量相同。</p><h3 id="张量点积"><a href="#张量点积" class="headerlink" title="张量点积"></a>张量点积</h3><p>两个向量之间的点积是一个标量，一个矩阵和一个向量做点积的结果是一个向量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">z = np.dot(x, y)</span><br></pre></td></tr></table></figure></p><h3 id="张量变形"><a href="#张量变形" class="headerlink" title="张量变形"></a>张量变形</h3><p>指改变张量的行和列。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.array([[0., 1.],</span><br><span class="line">[2., 3.],</span><br><span class="line">[4., 5.]])</span><br><span class="line">&gt;&gt;&gt; print(x.shape)</span><br><span class="line">(3, 2)</span><br><span class="line">&gt;&gt;&gt; x = x.reshape((6, 1))</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">array([[ 0.],[ 1.],[ 2.],[ 3.],[ 4.],[ 5.]])</span><br><span class="line">&gt;&gt;&gt; x = x.reshape((2, 3))</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">array([[ 0., 1., 2.],</span><br><span class="line">[ 3., 4., 5.]])</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.zeros((300, 20))</span><br><span class="line">&gt;&gt;&gt; x = np.transpose(x)</span><br><span class="line">&gt;&gt;&gt; print(x.shape)</span><br><span class="line">(20, 300)</span><br></pre></td></tr></table></figure><h3 id="深度学习的几何解释"><a href="#深度学习的几何解释" class="headerlink" title="深度学习的几何解释"></a>深度学习的几何解释</h3><p>神经网络完全由一系列张量运算组成，而这些张量运算都只是输入数据的几何变换。深度网络的每一层都通过变换使数据解开一点点 —— 许多层堆叠在一起，可以实现非常复杂的解开过程</p><h2 id="神经网络的-“引擎”：基于梯度的优化"><a href="#神经网络的-“引擎”：基于梯度的优化" class="headerlink" title="神经网络的 “引擎”：基于梯度的优化"></a>神经网络的 “引擎”：基于梯度的优化</h2><p>一个训练循环的具体过程：</p><p>①. 抽取训练样本 x 和对应目标 y 组成的数据批量。<br>②. 在 x 上运行网络［这一步叫作前向传播（forward pass）］，得到预测值 y_pred。<br>③. 计算网络在这批数据上的损失，用于衡量 y_pred 和 y 之间的距离。<br>④. 计算损失相对于网络参数的梯度［一次反向传播（backward pass）］。<br>⑤. 将参数沿着梯度的反方向移动一点，比如 W -= step * gradient，从而使这批数据上的损失减小一点。</p><p>这叫小批量随机梯度下降（mini-batch stochastic gradient descent，小批量 SGD）。</p><p>此外，SGD 还有多种变体，其区别在于计算下一次权重更新时还要考虑上一次权重更新，而不是仅仅考虑当前梯度值，比如带动量的 SGD、Adagrad、RMSProp 等变体。这些变体被称为优化方法（optimization method）或优化器（optimizer）。其中动量的引入可以使优化过程避免进入局部极小点。</p><h1 id="第三章-神经网络入门"><a href="#第三章-神经网络入门" class="headerlink" title="第三章 神经网络入门"></a>第三章 神经网络入门</h1><h2 id="神经网络剖析"><a href="#神经网络剖析" class="headerlink" title="神经网络剖析"></a>神经网络剖析</h2><p>训练神经网络主要围绕以下四个方面：</p><p>①. 层，多个层组合成网络（或模型）。<br>②. 输入数据和相应的 目标。<br>③. 损失函数，即用于学习的反馈信号。<br>④. 优化器，决定学习过程如何进行。</p><h3 id="层：深度学习的基础组件"><a href="#层：深度学习的基础组件" class="headerlink" title="层：深度学习的基础组件"></a>层：深度学习的基础组件</h3><p>神经网络的基本数据结构是层。层是一个数据处理模块，将一个或多个输入张量转换为一个或多个输出张量。</p><p>不同的张量格式与不同的数据处理类型需要用到不同的层。例如，简单的向量数据保存在形状为 (samples, features) 的 2D 张量中，通常用全连接层（对应于 Keras 的 Dense 类）来处理。序列数据保存在形状为 (samples, timesteps, features) 的 3D 张量中，通常用循环层（recurrent layer，比如 Keras 的 LSTM 层）来处理。图像数据保存在 4D 张量中，通常用二维卷积层（Keras 的 Conv2D）来处理。</p><h3 id="模型：层构成的网络"><a href="#模型：层构成的网络" class="headerlink" title="模型：层构成的网络"></a>模型：层构成的网络</h3><p>深度学习模型是层构成的有向无环图。最常见的例子就是层的线性堆叠，将单一输入映射为单一输出。</p><p>一些常见的网络拓扑结构：双分支（two-branch）网络、多头（multihead）网络、Inception 模块。</p><p>网络的拓扑结构定义了一个假设空间（hypothesis space）。选定了网络拓扑结构，意味着将假设空间限定为一系列特定的张量运算，将输入数据映射为输出数据。然后，你需要为这些张量运算的权重张量找到一组合适的值。</p><h3 id="损失函数与优化器：配置学习过程的关键"><a href="#损失函数与优化器：配置学习过程的关键" class="headerlink" title="损失函数与优化器：配置学习过程的关键"></a>损失函数与优化器：配置学习过程的关键</h3><p>一旦确定了网络架构，还需要选择一下两个参数：</p><p>损失函数 —— 在训练过程中需要将其最小化。它能够衡量当前任务是否已经成功完成。<br>优化器 —— 决定如何基于损失函数对网络进行更新。它执行的是随机梯度下降（SGD）的某个变体。<br>具有多个输出的神经网络可能具有多个损失函数（每个输出对应一个损失函数）。但是，梯度下降过程必须基于单个标量损失值。因此，对于具有多个损失函数的网络，需要将所有损失函数取平均，变为一个标量值。</p><p>可以遵循一些简单的指导原则来选择正确的损失函数：</p><p>①. 二分类问题：使用二元交叉熵（binary crossentropy）损失函数；</p><p>②. 多分类问题：使用分类交叉熵（categorical crossentropy）损失函数；</p><p>③. 回归问题：均方误差（mean-squared error）损失函数；</p><p>④. 序列学习问题：联结主义时序分类（CTC, connectionist temporal classification）损失函数。</p><h2 id="Keras-简介"><a href="#Keras-简介" class="headerlink" title="Keras 简介"></a>Keras 简介</h2><h3 id="Keras、TensorFlow"><a href="#Keras、TensorFlow" class="headerlink" title="Keras、TensorFlow"></a>Keras、TensorFlow</h3><p>Keras 是一个模型级（model-level）的库，为开发深度学习模型提供了高层次的构建模块。它不处理张量操作、求微分等低层次的运算。相反，它依赖于一个专门的、高度优化的张量库来完成这些运算，这个张量库就是 Keras 的后端引擎（backend engine）。Keras 没有选择单个张量库并将 Keras 实现与这个库绑定，而是以模块化的方式处理这个问题。因此，几个不同的后端引擎都可以无缝嵌入到 Keras 中。</p><p>深度学习的软件栈和硬件栈<br>深度学习的软件栈和硬件栈</p><p>通过 TensorFlow（或 Theano、CNTK），Keras 可以在 CPU 和 GPU 上无缝运行。在 CPU 上运行时，TensorFlow 本身封装了一个低层次的张量运算库，叫作 Eigen；在 GPU 上运行时，TensorFlow 封装了一个高度优化的深度学习运算库，叫作 NVIDIA CUDA 深度神经网络库（cuDNN）。</p><h3 id="使用-Keras-开发：概述"><a href="#使用-Keras-开发：概述" class="headerlink" title="使用 Keras 开发：概述"></a>使用 Keras 开发：概述</h3><p>典型 Keras 工作流程：</p><p>①. 定义训练数据：输入张量和目标张量。<br>②. 定义层组成的网络（或模型），将输入映射到目标。<br>③. 配置学习过程：选择损失函数、优化器和需要监控的指标。<br>④. 调用模型的 fit 方法在训练数据上进行迭代。</p><p>定义模型有两种方法：一种是使用 Sequential 类（仅用于层的线性堆叠，这是目前最常见的网络架构），另一种是函数式 API（functional API，用于层组成的有向无环图，让你可以构建任意形式的架构）。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#一个利用Sequential类定义的两层模型</span><br><span class="line">from keras import models</span><br><span class="line">from keras import layers</span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(32, activation=&#x27;relu&#x27;, input_shape=(784,)))</span><br><span class="line">model.add(layers.Dense(10, activation=&#x27;softmax&#x27;))</span><br></pre></td></tr></table></figure><br>配置学习过程是在编译这一步，你需要指定模型使用的优化器和损失函数，以及训练过程中想要监控的指标。下面是单一损失函数的例子，这也是目前最常见的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from keras import optimizers</span><br><span class="line">model.compile(optimizer=optimizers.RMSprop(lr=0.001),</span><br><span class="line">               loss=&#x27;mse&#x27;,</span><br><span class="line">               metrics=[&#x27;accuracy&#x27;])</span><br></pre></td></tr></table></figure><br>最后，学习过程就是通过 fit () 方法将输入数据的 Numpy 数组（和对应的目标数据）传入模型。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(input_tensor, target_tensor, batch_size=128, epochs=10)</span><br></pre></td></tr></table></figure></p><h2 id="新闻分类-——-多分类问题"><a href="#新闻分类-——-多分类问题" class="headerlink" title="新闻分类 —— 多分类问题"></a>新闻分类 —— 多分类问题</h2><p>应该从这个例子中学到的要点：</p><p>①. 如果要对 N 个类别的数据点进行分类，网络的最后一层应该是大小为 N 的 Dense 层。<br>②. 对于单标签、多分类问题，网络的最后一层应该使用 softmax 激活，这样可以输出在 N 个输出类别上的概率分布。<br>③. 这种问题的损失函数几乎总是应该使用分类交叉熵（categorical crossentropy）。它将网络输出的概率分布与目标的真实分布之间的距离最小化。<br>④. 处理多分类问题的标签有两种方法。<br>通过分类编码（也叫 one-hot 编码）对标签进行编码，然后使用 categorical_<br>crossentropy 作为损失函数。<br>将标签编码为整数，然后使用 sparse_categorical_crossentropy 损失函数。<br>⑤. 如果你需要将数据划分到许多类别中，应该避免使用太小的中间层，以免在网络中造成信息瓶颈。</p><h1 id="第四章-机器学习基础"><a href="#第四章-机器学习基础" class="headerlink" title="第四章 机器学习基础"></a>第四章 机器学习基础</h1><h2 id="机器学习的四个分支"><a href="#机器学习的四个分支" class="headerlink" title="机器学习的四个分支"></a>机器学习的四个分支</h2><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>给定一组样本（通常由人工标注），它可以学会将输入数据映射到已知目标［也叫标注（annotation）］。一般来说，近年来广受关注的深度学习应用几乎都属于监督学习，比如光学字符识别、语音识别、图像分类和语言翻译。</p><p>监督学习主要包括分类回归，但也有其它变体（在此先暂不讨论）。</p><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>无监督学习是指在没有目标的情况下寻找输入数据的有趣变换，其目的在于数据可视化、数据压缩、数据去噪或更好地理解数据中的相关性。降维 （dimensionality reduction）和聚类（clustering）都是众所周知的无监督学习方法。</p><h3 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h3><p>自监督学习是没有人工标注的标签的监督学习，标签是从输入数据中生成的，通常是使用启发式算法生成的。</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>在强化学习中，智能体（agent）接收有关其环境的信息，并学会选择使某种奖励最大化的行动。例如，神经网络会 “观察” 视频游戏的屏幕并输出游戏操作，目的是尽可能得高分，这种神经网络可以通过强化学习来训练。</p><h2 id="评估机器学习模型"><a href="#评估机器学习模型" class="headerlink" title="评估机器学习模型"></a>评估机器学习模型</h2><p>随着训练的进行，模型在训练数据上的性能始终在提高，但在前所未见的数据上的性能则可能不再变化或者开始下降，这就是过拟合。</p><p>机器学习的目的是得到可以泛化（generalize）的模型，即在前所未见的数据上表现很好的模型，而过拟合则是核心难点。</p><h3 id="几种经典的评估方法"><a href="#几种经典的评估方法" class="headerlink" title="几种经典的评估方法"></a>几种经典的评估方法</h3><p>1.简单的留出验证<br>简单的留出验证数据划分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">num_validation_samples = 10000</span><br><span class="line"></span><br><span class="line">np.random.shuffle(data) # 通常需要打乱数据</span><br><span class="line"></span><br><span class="line">validation_data = data[:num_validation_samples] # 定义验证集</span><br><span class="line">data = data[num_validation_samples:]</span><br><span class="line"></span><br><span class="line">training_data = data[:] # 定义训练集</span><br><span class="line"></span><br><span class="line">#在训练数据上训练模型，并在验证数据上评估模型</span><br><span class="line">model = get_model()</span><br><span class="line">model.train(training_data)</span><br><span class="line">validation_score = model.evaluate(validation_data)</span><br><span class="line"></span><br><span class="line">#现在你可以调节模型、重新训练、评估，然后再次调节……</span><br><span class="line"></span><br><span class="line">#一旦调节好超参数，通常就在所有非测试数据上从头开始训练最终模型</span><br><span class="line">model = get_model()</span><br><span class="line">model.train(np.concatenate([training_data,validation_data]))</span><br><span class="line">test_score = model.evaluate(test_data)</span><br></pre></td></tr></table></figure><p>缺点：如果可用的数据很少，那么可能验证集和测试集包含的样本就太少，从而无法在统计学上代表数据。如果在划分数据前进行不同的随机打乱，最终得到的模型性能差别很大。<br>1.K 折验证<br>K 折验证（K-fold validation）将数据划分为大小相同的 K 个分区。对于每个分区 i，在剩余的 K-1 个分区上训练模型，然后在分区 i 上评估模型。最终分数等于 K 个分数的平均值。</p><p>2.带有打乱数据的重复 K 折验证<br>是多次使用 K 折验证，在每次将数据划分为 K 个分区之前都先将数据打乱。最终分数是每次 K 折验证分数的平均值。注意，这种方法一共要训练和评估 P×K 个模型（P 是重复次数），计算代价很大。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">k = 4</span><br><span class="line">num_validation_samples = len(data) // k</span><br><span class="line"></span><br><span class="line">np.random.shuffle(data) # 打乱数据</span><br><span class="line"></span><br><span class="line">validation_scores = []</span><br><span class="line">for fold in range(k):</span><br><span class="line"># 选择验证数据分区</span><br><span class="line">validation_data = data[num_validation_samples * fold:</span><br><span class="line">num_validation_samples * (fold + 1)]</span><br><span class="line"># 使用剩余数据作为训练数据，“+”运算符是列表合并，不是求和</span><br><span class="line">training_data = data[:num_validation_samples * fold] +</span><br><span class="line">data[num_validation_samples * (fold + 1):]</span><br><span class="line"></span><br><span class="line">    # 创建一个全新的模型实例(未训练)</span><br><span class="line">    model = get_model()</span><br><span class="line">    model.train(training_data)</span><br><span class="line">    validation_score = model.evaluate(validation_data)</span><br><span class="line">    validation_scores.append(validation_score)</span><br><span class="line"></span><br><span class="line"># 最终验证分数：K折验证分数的平均值</span><br><span class="line">validation_score = np.average(validation_scores)</span><br><span class="line"></span><br><span class="line"># 在所有非测试数据上训练最终模型</span><br><span class="line">model = get_model()</span><br><span class="line">model.train(data)</span><br><span class="line">test_score = model.evaluate(test_data)</span><br></pre></td></tr></table></figure></p><h2 id="数据预处理、特征工程和特征学习"><a href="#数据预处理、特征工程和特征学习" class="headerlink" title="数据预处理、特征工程和特征学习"></a>数据预处理、特征工程和特征学习</h2><h3 id="神经网络的数据预处理"><a href="#神经网络的数据预处理" class="headerlink" title="神经网络的数据预处理"></a>神经网络的数据预处理</h3><p>数据预处理的目的是使原始数据更适于用神经网络处理。</p><ul><li>向量化:<br>神经网络的所有输入和目标都必须是浮点数张量（在特定情况下可以是整数张量）。无论处理什么数据（声音、图像还是文本），都必须首先将其转换为张量，这一步叫作数据向量化（data vectorization）。</li></ul><ul><li>值标准化:<br>为了让网络的学习变得更容易，输入数据应该具有以下特征：  取值较小：大部分值都应该在 0-1 范围内<br>同质性：所有特征的取值都应该在大致相同的范围内</li></ul><ul><li>处理缺失值:<br>如果不是所有样本都具有这个特征的话，那样你的训练数据或测试数据将会有缺失值。一般来说，对于神经网络，将缺失值设置为 0 是安全的，只要 0 不是一个有意义的值。网络能够从数据中学到 0 意味着缺失数据，并且会忽略这个值。</li></ul><p>注意，如果测试数据中可能有缺失值，而网络是在没有缺失值的数据上训练的，那么网络不可能学会忽略缺失值。在这种情况下，你应该人为生成一些有缺失项的训练样本：多次复制一些训练样本，然后删除测试数据中可能缺失的某些特征。</p><h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><p>特征工程（feature engineering）是指将数据输入模型之前，利用你自己关于数据和机器学习算法（这里指神经网络）的知识对数据进行硬编码的变换（不是模型学到的），以改善模型的效果。多数情况下，一个机器学习模型无法从完全任意的数据中进行学习。呈现给模型的数据应该便于模型进行学习。</p><p>特征工程的本质：用更简单的方式表述问题，从而使问题变得更容易。它通常需要深入理解问题。</p><p>对于现代深度学习，大部分特征工程都是不需要的，因为神经网络能够从原始数据中自动提取有用的特征</p><h2 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h2><p>机器学习的根本问题是优化和泛化之间的对立。优化（optimization）是指调节模型以在训练数据上得到最佳性能（即机器学习中的学习）， 而泛化（generalization）是指训练好的模型在前所未见的数据上的性能好坏。</p><p>训练开始时，优化和泛化是相关的：训练数据上的损失越小，测试数据上的损失也越小，这时的模型是欠拟合（underfit）的。但在训练数据上迭代一定次数之后，泛化不再提高，验证指标先是不变，然后开始变差， 即模型开始过拟合。这时模型开始学习仅和训练数据有关的模式，但这种模式对新数据来说是错误的或无关紧要的。</p><p>防止过拟合的最优解决方法是获取更多的训练数据，模型的训练数据越多，泛化能力自然也越好。如果无法获取更多数据，次优解决方法是调节模型允许存储的信息量，或对模型允许存储的信息加以约束。如果一个网络只能记住几个模式，那么优化过程会迫使模型集中学习最重要的模式，这样更可能得到良好的泛化。这种降低过拟合的方法叫做正则化（regularization）。下面介绍几种最常见的正则化方法。</p><h3 id="减少网络大小"><a href="#减少网络大小" class="headerlink" title="减少网络大小"></a>减少网络大小</h3><p>防止过拟合的最简单的方法就是减小模型大小，即减少模型中可学习参数的个数（这由层数和每层的单元个数决定）。在深度学习中，模型中可学习参数的个数通常被称为模型的容量（capacity）。 直观上来看，参数更多的模型拥有更大的记忆容量（memorization capacity），因此能够在训练样本和目标之间轻松地学会完美的字典式映射，这种映射没有任何泛化能力。</p><h3 id="添加权重正则化"><a href="#添加权重正则化" class="headerlink" title="添加权重正则化"></a>添加权重正则化</h3><p>一种常见的降低过拟合的方法就是强制让模型权重只能取较小的值，从而限制模型的复杂度，这使得权重值的分布更加规则（regular）。这种方法叫作权重正则化（weight regularization），其实现方法是向网络损失函数中添加与较大权重值相关的成本（cost）。这个成本有两种形式。<br>①.L1 正则化（L1 regularization） ：添加的成本与权重系数的绝对值［权重的 L1 范数（norm）］成正比。<br>②. L2 正则化（L2 regularization）：添加的成本与权重系数的平方（权重的 L2 范数）成正比。神经网络的 L2 正则化也叫权重衰减（weight decay）。不要被不同的名称搞混，权重衰减与 L2 正则化在数学上是完全相同的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from keras import regularizers</span><br><span class="line"></span><br><span class="line">#向分类网络中添加L2权重正则化</span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(16,kernel_regularizer=regularizers.l2(0.001),activation=&#x27;relu&#x27;, input_shape=(10000,)))</span><br><span class="line">model.add(layers.Dense(16,kernel_regularizer=regularizers.l2(0.001),activation=&#x27;relu&#x27;))</span><br><span class="line">model.add(layers.Dense(1, activation=&#x27;sigmoid&#x27;))</span><br></pre></td></tr></table></figure><br>l2 (0.001) 的意思是该层权重矩阵的每个系数都会使网络总损失增加 0.001 weight_coefficient_value。注意，由于这个惩罚项 * 只在训练时添加，所以这个网络的训练损失会比测试损失大很多。<br>还可以用以下这些权重正则化来代替 L2 正则化：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from keras import regularizers</span><br><span class="line"></span><br><span class="line">regularizers.l1(0.001) # L1正则化</span><br><span class="line"></span><br><span class="line">regularizers.l1_l2(l1=0.001, l2=0.001) # 同时做L1和L2正则化</span><br></pre></td></tr></table></figure></p><h3 id="添加-dropout-正则化"><a href="#添加-dropout-正则化" class="headerlink" title="添加 dropout 正则化"></a>添加 dropout 正则化</h3><p>dropout 是神经网络最有效也最常用的正则化方法之一。对某一层使用 dropout，就是在训练过程中随机将该层的一些输出特征舍弃（设置为 0）。其核心思想是在层的输出值中引入噪声，打破不显著的偶然模式（Hinton 称之为阴谋）。如果没有噪声的话，网络将会记住这些偶然模式。</p><p>dropout 比率（dropout rate）是被设为 0 的特征所占的比例，通常在 0.2~0.5 范围内。</p><p>向分类网络中添加两个 Dropout 层，看一下它们降低过拟合的效果。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#通过Dropout 层向网络中引入dropout，dropout 将被应用于前面一层的输出。</span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(16, activation=&#x27;relu&#x27;, input_shape=(10000,)))</span><br><span class="line">model.add(layers.Dropout(0.5))</span><br><span class="line">model.add(layers.Dense(16, activation=&#x27;relu&#x27;))</span><br><span class="line">model.add(layers.Dropout(0.5))</span><br><span class="line">model.add(layers.Dense(1, activation=&#x27;sigmoid&#x27;))</span><br></pre></td></tr></table></figure></p><h2 id="机器学习的通用工作流程"><a href="#机器学习的通用工作流程" class="headerlink" title="机器学习的通用工作流程"></a>机器学习的通用工作流程</h2><h3 id="定义问题、收集数据集"><a href="#定义问题、收集数据集" class="headerlink" title="定义问题、收集数据集"></a>定义问题、收集数据集</h3><p>首先，你必须定义所面对的问题。</p><p>你的输入数据是什么？你要预测什么？只有拥有可用的训练数据，你才能学习预测某件事情。比如，只有同时拥有电影评论和情感标注，你才能学习对电影评论进行情感分类。因此，数据可用性通常是这一阶段的限制因素。</p><p>你面对的是什么类型的问题？是二分类问题、多分类问题、标量回归问题、向量回归问题，还是多分类、多标签问题？或者是其他问题，比如聚类、生成或强化学习？确定问题类型有助于你选择模型架构、损失函数等。</p><p>只有明确了输入、输出以及所使用的数据，你才能进入下一阶段。注意你在这一阶段所做的假设。</p><p>假设输出是可以根据输入进行预测的。<br>假设可用数据包含足够多的信息，足以学习输入和输出之间的关系。</p><h3 id="选择衡量成功的指标"><a href="#选择衡量成功的指标" class="headerlink" title="选择衡量成功的指标"></a>选择衡量成功的指标</h3><p>对于多分类问题，成功的定义就是分类的精度。 可以使用平均准确率均值（mean average precision）作为指标。</p><h3 id="确定评估方法"><a href="#确定评估方法" class="headerlink" title="确定评估方法"></a>确定评估方法</h3><p>三种常见的评估方法：</p><p>留出验证集：数据量很大时采用</p><p>K 折交叉验证：如果留出验证的样本量太少时可以采用</p><p>重复的 K 折验证：如果可用的数据很少，同时模型评估又需要非常准确，那么应该使用这种方法</p><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>将数据格式化，使其可以输入到机器学习模型中。</p><p>数据格式化为张量<br>张量的取值通常应该缩放为较小的值，比如在 $[-1,1]$ 区间或 $[0,1]$ 区间<br>如果不同特征具有不同的取值范围，那么应该做数据标准化<br>可能需要做特征工程，尤其是对于小数据问题</p><h3 id="开发比基准更好的模型"><a href="#开发比基准更好的模型" class="headerlink" title="开发比基准更好的模型"></a>开发比基准更好的模型</h3><p>开发一个小型模型，它能够打败纯随机的基准，即获得统计功效。</p><p>想获得统计功效，必须有两个假设：</p><p>假设输出是可以根据输入进行预测的<br>假设可用的数据包含足够多的信息，足以学习输入和输出之间的关系<br>如果一切顺利，还需要选择三个关键参数来构建第一个构建模型：</p><p>①. 最后一层的激活。它对网络输出进行有效的限制。例如，IMDB 分类的例子在最后一层使用了 sigmoid，回归的例子在最后一层没有使用激活，等等。<br>②. 损失函数。它应该匹配你要解决的问题的类型。例如，IMDB 的例子使用 binary_crossentropy、回归的例子使用 mse，等等。<br>③. 优化配置。你要使用哪种优化器？学习率是多少？大多数情况下，使用 rmsprop 及其默认的学习率是稳妥的。</p><p>为模型选择正确的最后一层激活和损失函数</p><h3 id="扩大模型规模：开发过拟合的模型"><a href="#扩大模型规模：开发过拟合的模型" class="headerlink" title="扩大模型规模：开发过拟合的模型"></a>扩大模型规模：开发过拟合的模型</h3><p>机器学习中无处不在的对立是优化和泛化的对立，理想的模型是刚好在欠拟合和过拟合的界线上，在容量不足和容量过大的界线上。为了找到这条界线，必须穿过它。</p><p>要搞清楚需要多大的模型，就必须开发一个过拟合的模型：</p><p>①. 添加更多的层。<br>②. 让每一层变得更大。<br>③. 训练更多的轮次。</p><p>要始终监控训练损失和验证损失，以及你所关心的指标的训练值和验证值。如果你发现模型在验证数据上的性能开始下降，那么就出现了过拟合。</p><p>下一阶段开始正则化和调节模型，以便尽可能地接近理想模型，既不过拟合也不欠拟合。</p><h3 id="模型正则化与调节超参数"><a href="#模型正则化与调节超参数" class="headerlink" title="模型正则化与调节超参数"></a>模型正则化与调节超参数</h3><p>这一步最费时间</p><p>你将不断地调节模型、训练、在验证数据上评估（这里不是测试数据）、再次调节模型，然后重复这一过程，直到模型达到最佳性能。你应该尝试以下几项。</p><p>①. 添加 dropout。<br>②. 尝试不同的架构：增加或减少层数。<br>③. 添加 L1 和 / 或 L2 正则化。<br>④. 尝试不同的超参数（比如每层的单元个数或优化器的学习率），以找到最佳配置。<br>⑤.（可选）反复做特征工程：添加新特征或删除没有信息量的特征。</p><p>一旦开发出令人满意的模型配置，你就可以在所有可用数据（训练数据 + 验证数据）上训练最终的生产模型，然后在测试集上最后评估一次。如果测试集上的性能比验证集上差很多，那么这可能意味着你的验证流程不可靠，或者你在调节模型参数时在验证数据上出现了过拟合。在这种情况下，你可能需要换用更加可靠的评估方法，比如重复的 K 折验证。</p><h1 id="第五章-深度学习用于计算机视觉"><a href="#第五章-深度学习用于计算机视觉" class="headerlink" title="第五章 深度学习用于计算机视觉"></a>第五章 深度学习用于计算机视觉</h1><h2 id="卷积神经网络简介"><a href="#卷积神经网络简介" class="headerlink" title="卷积神经网络简介"></a>卷积神经网络简介</h2><h3 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h3><p>密集连接层和卷积层的根本区别在于，Dense 层从输入特征空间中学到的是全局模式，而卷积层学到的是局部模式，对于图像来说，学到的就是在输入图像的二维小窗口中发现的模式。</p><p>图像可以被分解为局部模式，如边缘、纹理等<br>图像可以被分解为局部模式，如边缘、纹理等</p><p>这个重要特性使卷积神经网络具有以下两个有趣的性质。</p><p>卷积神经网络学到的模式具有平移不变性（translation invariant）。卷积神经网络在图像右下角学到某个模式之后，它可以在任何地方识别这个模式，比如左上角。对于密集连接网络来说，如果模式出现在新的位置，它只能重新学习这个模式。 这使得卷积神经网络在处理图像时可以高效利用数据（因为视觉世界从根本上具有平移不变性），它只需要更少的训练样本就可以学到具有泛化能力的数据表示。<br>卷积神经网络可以学到模式的空间层次结构（spatial hierarchies of patterns）。第一个卷积层将学习较小的局部模式（比如边缘），第二个卷积层将学习由第一层特征组成的更大的模式，以此类推。这使得卷积神经网络可以有效地学习越来越复杂、越来越抽象的视觉概念 （因为视觉世界从根本上具有空间层次结构）。<br>对于包含两个空间轴（高度和宽度） 和一个深度轴（也叫通道轴）的 3D 张量， 其卷积也叫特征图（feature map）。对于 RGB 图像，深度轴的维度大小等于 3，因为图像有 3 个颜色通道：红色、绿色和蓝色。对于黑白图像（比如 MNIST 数字图像），深度等于 1（表示灰度等级）。卷积运算从输入特征图中提取图块，并对所有这些图块应用相同的变换， 生成输出特征图（output feature map）。该输出特征图仍是一个 3D 张量，具有宽度和高度，其深度可以任意取值，因为输出深度是层的参数，深度轴的不同通道不再像 RGB 输入那样代表特定颜色，而是代表 过滤器（filter）。</p><p>视觉世界形成了视觉模块的空间层次结构：超局部的边缘组合成局部的对象，<br>比如眼睛或耳朵，这些局部对象又组合成高级概念，比如 “猫”<br>视觉世界形成了视觉模块的空间层次结构：超局部的边缘组合成局部的对象，<br>比如眼睛或耳朵，这些局部对象又组合成高级概念，比如 “猫”</p><p>在 MNIST 示例中，第一个卷积层接收一个大小为 (28, 28, 1) 的特征图，并输出一个大小为 (26, 26, 32) 的特征图，即它在输入上计算 32 个过滤器。对于这 32 个输出通道，每个通道都包含一个 26×26 的数值网格，它是过滤器对输入的响应图（response map），表示这个过滤器模式在输入中不同位置的响应。 这也是特征图这一术语的含义：深度轴的每个维度都是一个特征（或过滤器）， 而 2D 张量 output [:, :, n] 是这个过滤器在输入上的响应的二维空间图（map）。</p><p>响应图的概念：某个模式在输入中的不同位置是否存在的二维图<br>响应图的概念：某个模式在输入中的不同位置是否存在的二维图</p><p>卷积由以下两个关键参数所定义:<br>①. 从输入中提取的图块尺寸：这些图块的大小通常是 3×3 或 5×5。<br>②. 输出特征图的深度：卷积所计算的过滤器的数量。</p><p>对于 Keras 的 Conv2D 层，这些参数都是向层传入的前几个参数：Conv2D (output_depth,(window_height, window_width))。</p><p>卷积的工作原理：在 3D 输入特征图上滑动（slide）这些 3×3 或 5×5 的窗口，在每个可能的位置停止并提取周围特征的 3D 图块［形状为 (window_height, window_width, input_depth)］。然后每个 3D 图块与学到的同一个权重矩阵［叫作卷积核（convolution kernel）］做张量积，转换成形状为 (output_depth,) 的 1D 向量。然后对所有这些向量进行空间重组，使其转换为形状为 (height, width, output_depth) 的 3D 输出特征图。输出特征图中的每个空间位置都对应于输入特征图中的相同位置（比如输出的右下角包含了输入右下角的信息）。举个例子，利用 3×3 的窗口，向量 output [i, j, :] 来自 3D 图块 input [i-1:i+1,j-1:j+1, :]。</p><h3 id="卷积的工作原理"><a href="#卷积的工作原理" class="headerlink" title="卷积的工作原理"></a>卷积的工作原理</h3><p>卷积的工作原理<br>注意，输出的宽度和高度可能与输入的宽度和高度不同。不同的原因可能有两点。<br>①. 边界效应，可以通过对输入特征图进行填充来抵消。如果你希望输出特征图的空间维度与输入相同，那么可以使用填充（padding）。填充是在输入特征图的每一边添加适当数目的行和列，使得每个输入方块都能作为卷积窗口的中心。对于 Conv2D 层，可以通过 padding 参数来设置填充，这个参数有两个取值：”valid” 表示不使用填充（只使用有效的窗口位置）；”same“表示 “填充后输出的宽度和高度与输入相同”。padding 参数的默认值为”valid”。<br>②. 使用了步幅（stride）。两个连续窗口的距离是卷积的一个参数，叫作步幅，默认值为 1。 也可以使用步进卷积（strided convolution），即步幅大于 1 的卷积。步幅为 2 意味着特征图的宽度和高度都被做了 2 倍下采样（除了边界效应引起的变化）。</p><p>为了对特征图进行下采样，我们不用步幅，而是通常使用最大池化（max-pooling）运算。</p><h3 id="最大池化运算"><a href="#最大池化运算" class="headerlink" title="最大池化运算"></a>最大池化运算</h3><p>最大池化的作用：对特征图进行下采样。最大池化使用硬编码的 max 张量运算对局部图块进行变换，而不是学到的线性变换（卷积核）。最大池化通常使用 2×2 的窗口和步幅 2，其目的是将特征图下采样 2 倍。</p><p>使用下采样的原因，一是减少需要处理的特征图的元素个数，二是通过让连续<br>卷积层的观察窗口越来越大（即窗口覆盖原始输入的比例越来越大），从而引入空间过滤器的层级结构。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine-Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百年孤独</title>
      <link href="/post/book.html"/>
      <url>/post/book.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>“他的小说以丰富的想象编织了一个现实与幻想交相辉映的世界，反映了一个大陆的生命与矛盾 “ —— 瑞典学院</p></div><p><img src="https://www.hualigs.cn/image/609f7d46385bf.jpg" alt=""></p><h1 id="First"><a href="#First" class="headerlink" title="First"></a>First</h1><p>他在没有爱情的荒漠中所结识的那些女人，多得不可胜数，她们把他的种子撒播在整个加勒比海岸，但没有在他的感情上留下一丝痕迹。她们大多是摸黑进房来，拂晓前离去，第二天他醒来时，只有对她们肉体的一点索然无味的回忆。<br>一个幸福晚年的秘决不是别的，而是与孤寂签订一个体面的协定。</p><h1 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h1><p>某些人的爱情，只是一种当时的情绪，如果对方错将这份情绪当做长远的感情，是本身的幼稚。<br>你如此憎恶军人，跟他们打了这么多的仗，对他们琢磨了这么久，到头来还是成了同他们一样的人。人生中没有比这更卑贱的理想了。<br>死亡跟他没有什么关系，而生命对他才有意义。</p><h1 id="Third"><a href="#Third" class="headerlink" title="Third"></a>Third</h1><p>她身上披着蔑视一切的厚厚的盔甲，这是世间的任何诱惑都无法刺破的。<br>这个家庭的历史是一架周而复始无法停息的机器，是一个转动着的轮子，这只齿轮，要不是轴会逐渐不可避免地磨损的话，会永远旋转下去。——(哥伦比亚) 加西亚・马尔克斯《百年孤独》<br>每一个生命都有灵魂，只是怎样唤醒他们…… ——(哥伦比亚) 加西亚・马尔克斯《百年孤独》<br>他没有察觉到时光在家里造成的细微而又令人心碎的破坏，这么长日子外出之后，对任何一个有着清晰记忆的人来说，这种破坏都会觉得是一种灾难。<br>上帝似乎决意要考验一下人们的全部惊讶能力，他让马贡多的人们总是处于不停的摇摆和游移之中，一会儿高兴，一会儿失望；一会儿百思不解，一会儿疑团冰释，以至谁也搞不清现实的界限究竟在哪里。<br>我们打了这么多年仗，一切只不过是为了别把我们的房子涂成蓝色。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>并不是聊得来，就适合在一起；并不是适合，就能够在一起；并不是能够在一起就会永远在一起；也并不是永远在一起了就会幸福的。<br>这个无奇不有的世界上也一定会有一个男人以他无以伦比的无所谓态度来对付她的。</p>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/hello-world.html"/>
      <url>/post/hello-world.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>微语</title>
      <link href="/artitalk/index.html"/>
      <url>/artitalk/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>图库</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img" src='https://www.hualigs.cn/image/60a0e62c4ea81.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁紙一</div>  <p>收藏的一些壁紙</p>  <a href='/gallery/gallery1'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img" src='https://z3.ax1x.com/2021/11/05/IuYlfx.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁纸二</div>  <p>關於圖片</p>  <a href='/gallery/gallery2'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img" src='https://z3.ax1x.com/2021/11/05/Iutr5R.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁纸三</div>  <p>關於圖片</p>  <a href='/gallery/gallery3'></a>  </figcaption>  </figure>  </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>archives</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%20_data/link.json"/>
      <url>/%20_data/link.json</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"聚宝盒","link":"https://yangchaoyi.vip/box/","avatar":"https://cdn.jsdelivr.net/gh/Yafine/cdn@3.2.1/source/box/images/logo/cnblogs.png","descr":"面向程序猿的专用导航"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"},{"name":"路过图床","link":"https://imgtu.com/","avatar":"https://cdn.jsdelivr.net/gh/Yafine/cdn@3.2.1/source/box/images/logo/imgchr.png","descr":"路过图床-高速稳定的图片上传和外链服务"}]}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><div class="note purple icon modern"><i class="note-icon fas fa-fan"></i><p>~IU歌单~</p></div>    <div id="aplayer-pazxVEsK" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="2227373273" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>壁纸一</title>
      <link href="/gallery/gallery1/index.html"/>
      <url>/gallery/gallery1/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><div class="justified-gallery"><p><img src="https://www.hualigs.cn/image/609fd775e8a7b.jpg" alt=""><br><img src="https://z3.ax1x.com/2021/11/05/Iut68x.jpg" alt=""><br><img src="https://z3.ax1x.com/2021/11/05/Iutc26.jpg" alt=""><br><img src="https://z3.ax1x.com/2021/11/05/Iutr5R.jpg" alt=""></p>          </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>壁纸二</title>
      <link href="/gallery/gallery2/index.html"/>
      <url>/gallery/gallery2/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><div class="justified-gallery"><p><img src="https://www.hualigs.cn/image/60a0e62c4ea81.jpg" alt=""><br><img src="https://www.hualigs.cn/image/60a0e62b10935.jpg" alt=""><br><img src="https://www.hualigs.cn/image/60a0e62b8a821.jpg" alt=""><br><img src="https://z3.ax1x.com/2021/11/05/IuY0ht.jpg" alt=""></p>          </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>壁纸三</title>
      <link href="/gallery/gallery3/index.html"/>
      <url>/gallery/gallery3/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><div class="justified-gallery"><p><img src="https://www.hualigs.cn/image/60a0e62c77916.jpg" alt=""></p>          </div>]]></content>
      
    </entry>
    
    
  
</search>
